\section{First-order rational tree functions}\label{sec:fo-translation}

To formalise the replacement mentioned in step (a), we use the following definition. The definition is more general than needed for step (a), since it allows the new label of a node to depend not just on the node's subtree, but also no the rest of the tree. These sort of two-way dependencies will play a role in Section~\ref{sec:one-register}.


\begin{definition}[First-order rational tree functions] \label{def:forat}\ 
    \begin{itemize}
        \item \emph{Characteristic functions.}  Let $\rSigma$ be a finite ranked set, and let $\varphi(x)$ be a first-order formula with one free variable over the vocabulary associated to tree models over alphabet $\rSigma$. The \emph{characteristic function of $\varphi$} 
        \begin{align*}
            \mathrm{char}_\varphi : \trees \rSigma \to \trees (\rSigma + \rSigma)
        \end{align*}
        is defined to be the function which inputs a tree, and returns a tree with the same nodes, but where the labels are changed so that the first copy of $\rSigma$ is used for nodes that satisfy  $\varphi(x)$, and the second copy is used for the other nodes.
        \item \emph{Homomorphism.} A \emph{tree homomorphism} is defined to be any function
        \begin{align*}
            f : \trees \rSigma \to \trees \rGamma
        \end{align*} 
        which applies some arity preserving function $\ranked f : \rSigma \to \tmonad \rGamma$ to each node in the input tree. 
        \item \emph{First-order rational tree function}. A first-order rational tree function is defined to be any composition $f_1 \circ \cdots \circ f_n$, where each $f_i$ is either a characteristic function or a tree homomorphism.
    \end{itemize}
      \end{definition}

% \begin{lemma}
%     Every first-order streaming tree transducer is equivalent to one where all registers have arity 1.
% \end{lemma}


The main  result of Section~\ref{sec:fo-translation} is the following proposition, which says  that all first-order rational tree functions can be derived from the atomic functions using the combinators. 
\begin{proposition} \label{prop:forat}    
    Let $\rSigma,\rGamma$ be finite ranked sets. 
    For every  first-order rational tree function 
    \begin{align*}
        f : \trees \rSigma \to \trees \rGamma,
    \end{align*}
    there is a function $\ranked f : \tmonad \rSigma \to \tmonad \rGamma$ which agrees with $f$ on trees, and which can be derived from the atomic functions using the combinators. 
\end{proposition}       
Since the combinators include function composition, it is enough to show the above proposition for the case when $f$ is either a characteristic function, or a tree homomorphism. 

For tree homomorphisms, we use the composition of the two functions
\begin{align*}
    \xymatrix{
        \tmonad \rSigma \ar[r]^{\tmonad \ranked f} & \tmonad \tmonad \rGamma \ar[r]^{\flatt_\rGamma} & \tmonad \rGamma,
    }
\end{align*}
where $\ranked f : \rSigma \to \tmonad \rGamma$ is an atomic function because it has a finite domain.  

The interesting case in Proposition~\ref{prop:forat} is when $f$ is a characteristic function. Here, the key step is a tree version of Kamp's Theorem, which is stated in the following lemma. The lemma is an immediate corollary of a result by Schlingloff~\cite[Theorem 2.6]{schlingloff1992expressive}, which says that a tree version of {\sc ltl} for trees is expressively complete for first-order logic.  


\begin{lemma}\label{lem:schlingloff} Every characteristic function (of a first-order query on trees) can be decomposed as a composition of characteristic functions of the following three kinds of  queries:
    \begin{enumerate}
        \item \emph{Child.} For every $\rSigma$ and  $i \in \set{1,2,\ldots}$, a query $\varphi(x)$ defined by
        \begin{align*}
            \underline t \models \varphi(x) \quad \text{iff} \quad \text{$x$ is an $i$-th child}\qquad \text{for every $t \in \trees \rSigma$}
        \end{align*}
         \item \emph{Until.} For every $\rGamma, \rDelta \subseteq \rSigma$, a query $\varphi(x)$ defined by
         \begin{align*}
             \underline t \models \varphi(x) \quad \text{iff} \quad \underbrace{\exists y\ y > x \land \rDelta(y) \land  \forall z \ (x < z < y \Rightarrow \rGamma(z))}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}}  \qquad \text{for every $t \in  \trees \rSigma$}
         \end{align*} 
         \item \emph{Since.} For every $\rGamma, \rDelta \subseteq \rSigma$,  a query $\varphi(x)$ defined by
         \begin{align*}
             \underline t \models \varphi(x) \quad \text{iff} \quad \underbrace{\exists y\ y < x \land \rDelta(y) \land  \forall z \ (y < z < x \Rightarrow \rGamma(z))}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}}  \qquad \text{for every $t \in  \trees \rSigma$}
         \end{align*} 
    \end{enumerate}
\end{lemma}

