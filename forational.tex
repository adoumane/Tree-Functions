\section{First-order tree relabellings}\label{sec:fo-translation}
The rest of the paper is devoted to the left-to-right implication in Theorem~\ref{thm:main}, which says that every first-order tree-to-tree transduction is derivable. As discussed in the proof strategy from Section~\ref{sec:strategy}, we begin with a special case of first-order tree-to-tree transductions, namely first-order relabellings. 

Define a \emph{unary   query over $\rSigma$} to be a first-order formula $\varphi(x)$ with one free variable, which uses the  vocabulary of models associated to  trees over $\rSigma$, as per Definition~\ref{def:tree-model}. Given a tree over $\rSigma$, a unary  query selects a subset of nodes. An example of a unary query is ``$x$ has at least four ancestors''. 

\begin{definition}[First-order tree relabelling] \label{def:forat}  A \emph{first-order tree relabelling} is given by two finite ranked sets, called the \emph{input and output alphabets}, and a family 
    \begin{align*}
    \set{\varphi_a(x)}_{a \in \text{ output alphabet}}
    \end{align*}
    of unary queries over the input alphabet such that:
    \begin{enumerate}
        \item[(*)] for every tree over the input alphabet and node in that tree, there is a unique output letter $a$ such that $\varphi_a(x)$ selects the node; furthermore, the arity of $a$ is the same as the arity of (the label of) the node. 
    \end{enumerate}
The semantics of a  first-order tree relabelling is a function from trees over the input alphabet to trees over the output alphabet, which changes the label of every node in the input tree to the unique letter described in  (*). 
      \end{definition}
% In this section, we discuss first-order rational tree functions. These are compositions of two types of tree transformations: (a) characteristic functions of first-order query, which annotate nodes of the input tree with first-order definable information; (b) and tree homomorphisms, which replace letters in the input tree  by terms. 


% \begin{definition}[First-order rational tree functions] \label{def:forat}\ 
%     \begin{itemize}
%         \item \emph{Characteristic functions.}  Let $\rSigma$ be a finite ranked set, and let $\varphi(x)$ be a first-order formula with one free variable over the vocabulary associated to tree models over alphabet $\rSigma$. The \emph{characteristic function of $\varphi$} 
%         \begin{align*}
%             \mathrm{char}_\varphi : \trees \rSigma \to \trees (\rSigma + \rSigma)
%         \end{align*}
%         is defined to be the function which inputs a tree, and returns a tree with the same nodes, but where the labels are changed so that the first copy of $\rSigma$ is used for nodes that satisfy  $\varphi(x)$, and the second copy is used for the other nodes.
%         \item \emph{Homomorphism.} A \emph{tree homomorphism} is defined to be any function
%         \begin{align*}
%             f : \trees \rSigma \to \trees \rGamma
%         \end{align*} 
%         which applies some arity preserving function $\ranked f : \rSigma \to \tmonad \rGamma$ to each node in the input tree. 
%         \item \emph{First-order rational tree function}. A first-order rational tree function is defined to be any composition $f_1 \circ \cdots \circ f_n$, where each $f_i$ is either a characteristic function or a tree homomorphism\footnote{One can show that, without loss of generality, we can assume the composition $f_1 \circ \cdots \circ f_n$ to be such that $f_1$ is a tree homomorphism and the remaining functions are  characteristic functions. We do not need this result, so we do not prove it.
%         }.
%     \end{itemize}
%       \end{definition}

% \begin{lemma}
%     Every first-order streaming tree transducer is equivalent to one where all registers have arity 1.
% \end{lemma}

% First-order tree relabellings will be used as a basic pre-processing step in the automaton model that will be defined in Section~\ref{sec:stt}.
% The main  result of Section~\ref{sec:fo-translation} is the following proposition. 
% \begin{proposition} \label{prop:forat}    
%     Every first-order tree relabelling is derivable.
% \end{proposition}       
% Since the combinators include function composition, it is enough to show the above proposition for the case when $f$ is either a characteristic function, or a tree homomorphism. 

% For tree homomorphisms, we use the composition of the two functions
% \begin{align*}
%     \ranked{
%     \xymatrix{
%         \tmonad \rSigma \ar[r]^{\tmonad \ranked f} & \tmonad \tmonad \rGamma \ar[r]^{\flatt_\rGamma} & \tmonad \rGamma,
%     }}
% \end{align*}
% where $\ranked f : \rSigma \rto \tmonad \rGamma$ is an atomic function because it has a finite domain.  

A first-order tree relabelling is a very special case of a first-order tree-to-tree transduction, where only the labelling of the input tree is changed, while the universe as well as the child and descendant relations are not affected. 
The goal of this section is to prove the following proposition.
\begin{proposition} \label{prop:forat}    
    Every first-order tree relabelling is derivable.
\end{proposition}   
The key step in the proof is  Lemma~\ref{lem:schlingloff} below, which decomposes  first-order tree labellings into  simpler functions. 
For a unary query  over $\rSigma$,  its \emph{characteristic function} is the function of type
\begin{align*}
 \trees \rSigma \to \trees (\rSigma + \rSigma)
\end{align*}
which replaces the label of each node by its first or second copy, depending on whether the node is selected by the query. The following lemma shows that every first-order tree relabelling can be obtained by composing local label changes, together with characteristic functions of certain simple unary queries. 

\begin{lemma}\label{lem:schlingloff} The first-order tree relabellings are equal to the smallest class of functions which is closed under composition and which  contains the following functions:
    \begin{enumerate}
        \item \label{it:relabeling} \emph{Relabeling}. To every finite $\rGamma,\rSigma$ and $\ranked {f : \rSigma \to \rGamma}$, the tree lifting $\trees \ranked f : \trees \rSigma \to \trees \rGamma$.
        \item \label{it:child} \emph{Child.} For every $\rSigma$ and  $i \in \set{1,2,\ldots}$, the characteristic function of the  unary query 
        \begin{align*}
            \underbrace{\child i (x).}_{\text{$x$ is an $i$-th child}}
        \end{align*}
         \item \label{it:until} \emph{Until.} For every finite $\rGamma, \rDelta \subseteq \rSigma$,  the characteristic function of the unary query
         \begin{align*}
              \underbrace{\exists y\ y > x \land \rDelta(y) \land  \forall z \ (x < z < y \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}} 
         \end{align*} 
         \item \label{it:since}\emph{Since.} For every $\rGamma, \rDelta \subseteq \rSigma$,    the characteristic function of the unary query
         \begin{align*}
              \underbrace{\exists y\ y < x \land \rDelta(y) \land  \forall z \ (y < z < x \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}}  
         \end{align*} 
    \end{enumerate}
    In items \ref{it:child} -- \ref{it:since}, the alphabet is $\rSigma$, so the characteristic functions have type $\trees \rSigma \to \trees(\rSigma + \rSigma)$. 
\end{lemma}

Clearly the functions in the lemma are first-order tree relabellings, and first-order tree relabellings are easily seen to be closed under composition, which gives the right-to-left inclusion in the lemma. The hard part is the left-to-right inclusion, which says that every first-order tree relabelling can be decomposed into functions as in items~\ref{it:relabeling} -- \ref{it:since}. 
The first  step in the proof of  the right-to-left inclusion is the observation that  every first-order tree relabelling can be decomposed as 
\begin{align*}
    g \circ f_1 \circ \cdots \circ f_n
\end{align*}
where $g$ is a relabelling as in item~\ref{it:relabeling} of the lemma and each $f_i$ is a  characteristic function of some unary query (not necessarily of the simple form indicated in items~\ref{it:child} -- \ref{it:since} in the lemma). This is a simple observation: the functions $f_1,\ldots,f_n$ annotate the tree with the truth values of the unary queries used in the definition of the  first-order relabelling, and $g$ uses these truth values to select the appropriate output label. The hard part of the lemma is showing that each $f_i$  can be further decomposed into functions as indicated in the lemma. Here we use a result of Schlingloff~\cite[Theorem 2.6]{schlingloff1992expressive}, which says that all first-order definable tree properties can be defined using a temporal logic that has operators similar to the ones used in items~\ref{it:child} -- \ref{it:since} of the lemma. The exact reduction to Schlingloff's theorem is given in Appendix~\ref{sec:AppendixForat}.

In light of Lemma~\ref{lem:schlingloff},  Proposition~\ref{prop:forat} will follow once we  show that all functions  used in the lemma are derivable. The relabellings from item~\ref{it:relabeling} are immediate: we simply lift to terms (and therefore also trees) the function $\ranked f$, which is derivable by virtue of having a finite domain. For the remaining functions, an important role is played by the factorisation operations. We only do the proof for ??, the other cases can be found in Appendix~\ref{sec:AppendixForat}. 

\begin{center}
    proof for ??, which is one of the deleted examples
\end{center}