\section{First-order  relabellings}\label{sec:fo-translation}
In this section we prove that every first-order tree labelling, which is used in our transducer model to compute the register updates, is a derivable function. 
\begin{proposition} \label{prop:forat}    
    Every first-order relabelling is derivable.
\end{proposition}
This result is based on a result of Schlingloff~\cite[Theorem 4.5]{schlingloff1992expressive}, which gives a temporal logic for trees that has the same expressive power as first-order logic. The operators in this temporal logic (which are tree variants of the since and until operators of {\sc ltl}) can be viewed as very simple first-order relabellings; by the completeness result of Schlingloff it is enough to show that these operators are derivable.  

For a first-order  unary tree query  over $\rSigma$,  define its  \emph{characteristic function} to be the function of type
\begin{align*}
 \trees \rSigma \to \trees (\ranked{\rSigma + \rSigma})
\end{align*}
which replaces the label of each node by its first or second copy, depending on whether the node is selected by the query. The following lemma says that every first-order tree relabelling can be obtained by composing local label changes, together with characteristic functions of certain simple unary queries. 

\begin{lemma}\label{lem:schlingloff} The first-order tree relabellings are exactly the least class of functions which is closed under composition and which  contains the following functions:
    \begin{enumerate}
        \item \label{it:relabelling} \emph{Letter-to-letter homomorphisms}. For  every finite $\rGamma,\rSigma$ and $\ranked {f : \rSigma \to \rGamma}$, its tree lifting $\trees \ranked f : \trees \rSigma \to \trees \rGamma$.
        \item \label{it:temporal-operators} For every finite  $\rSigma$ and its subsets $\rDelta, \rGamma \subseteq \rSigma$, the characteristic functions of type
        \begin{align*}
            \trees \rSigma \to \trees(\ranked{\rSigma + \rSigma})
        \end{align*}
        of the following unary first-order tree queries:
        \begin{enumerate}
            \item \label{it:child} \emph{Child:} $x$ is an $i$-th child, for $i \in \set{1,2,\ldots}$
            \begin{align*}
            \child i (x); 
            \end{align*}
             \item \label{it:until} \emph{Until:}  $x$ has a descendant $y$ with label in $\rDelta$, such that all nodes strictly between $x$ and $y$ have label in $\rGamma$
             \begin{align*} 
                  \exists y\ y > x \land \rDelta(y) \land  \forall z \ (x < z < y \Rightarrow \rGamma(z));
             \end{align*} 
             \item \label{it:since}\emph{Since:} $x$ has a descendant $y$ with label in $\rDelta$, such that all nodes strictly between $x$ and $y$ have label in $\rGamma$
             \begin{align*}
                  \exists y\ y < x \land \rDelta(y) \land  \forall z \ (y < z < x \Rightarrow \rGamma(z)).
             \end{align*} 
        \end{enumerate}
    \end{enumerate}
    
\end{lemma}

The  lemma follows directly from Schlingloff~\cite[Theorem 2.6]{schlingloff1992expressive}, who proves that all first-order definable tree properties can be defined using a temporal logic that has operators similar to the ones used in items~\ref{it:temporal-operators} of the lemma. Note that the temporal logic is a two-way logic, because the truth value of \emph{until} depends on the descendants of the node $x$, while \emph{since} depends on the ancestors. In fact, there is no temporal logic which characterises first-order logic, uses only descendants, and has finitely many operators~\cite[Theorem 5.5]{bojanczykWreathProductsForest2012}. 
The exact reduction to Schlingloff's theorem is  in Appendix~\ref{sec:AppendixForat}.


In light of Lemma~\ref{lem:schlingloff},  Proposition~\ref{prop:forat} will follow once we  show that all functions  used in the lemma are derivable. The relabellings from item~\ref{it:relabelling} are derivable as  a special case of homomorphisms discussed in Example~\ref{ex:filter}.   The remaining functions are also derivable, as shown in Appendix~\ref{sec:AppendixForat}.
% i lemmas~\ref{lem:nextmod}, \ref {lem:untilmod} and \ref{lem:sincemod}. 