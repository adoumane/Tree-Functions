\section{Derivable functions}\label{sec:derivable-functions}
In this section, we state the main result of this paper: the  first-order tree-to-tree transductions are exactly the class which is obtained by starting with certain prime functions (such as depth-first traversal) and applying certain  combinators (such as function composition). 

\subsection{Datatypes}
\label{sec:datatype-constructors}
 Our goal is to describe tree-to-tree functions. However, we will decompose the functions, so that the   intermediate functions will work on other datatypes, such as pairs of trees or trees of trees etc. These datatypes  can be encoded in trees, but such encoding would be cumbersome. Following~\cite{bojanczykRegularFirstOrderList2018}, we  introduce additional  datatype constructors, such as pairing.

All datatypes represent ranked sets, i.e.~each element of a datatype has an arity. The atomic datatypes are finite ranked sets, e.g.~alphabets for trees. 

\paragraph*{Terms.} The most important datatype constructor is the  \emph{term} constructor. Terms generalise trees, by allowing for dangling edges, called ports. We allow ports so that we can decompose trees (and even terms) into smaller pieces, as  illustrated by the figure below. 
% Each  part of the tree is not a tree as it has dangling ports.  We call \emph{terms} such trees with ports. 
\begin{center}
\includegraphics[scale=.32, page=15]{pics.pdf}
\end{center}
Formally speaking, terms are defined by induction: a term over a (possibly infinite) ranked set $\rSigma$ is either a term which consists only of a port, 
or it is an expression of the  form $a \tensorpair{t_1,\ldots,t_n}$ where $a \in \rSigma$ has arity $n$, and $t_1,\ldots,t_n$ are already defined terms. The arity of a term is the number of ports. Terms of arity zero are the same as trees. We write $\tmonad \rSigma$ for the ranked set of terms over an ranked set $\rSigma$.    Terms form a monad, in the category of ranked sets and arity-preserving functions. The unit of the monad, which is an operation of type $\ranked{\rSigma \to \tmonad \rSigma}$, is illustrated in the following picture:
\mypic{98}
The product of the monad, which is an operation of type $\ranked{\tmonad \tmonad \rSigma \to \tmonad \rSigma}$ that we call \emph{flattening}, is illustrated in the following picture:
\mypic{97}

\paragraph*{Products and coproducts.}
We have two binary datatype constructors
\begin{align*}
\underbrace{\ranked{\Sigma_1 \otimes \Sigma_2}}_{\text{tensor product}} \qquad \underbrace{\ranked{\Sigma_1 + \Sigma_2}}_{\text{coproduct}}
\end{align*}
An element of the tensor product is a pair $\tensorpair{a_1,a_2}$ where $a_i \in \ranked{\Sigma_i}$. The arity of the pair is the sum of arities of $a_1$ and $a_2$. We draw pairs like this:
\mypic{52}     
An element of the coproduct is a pair $(i,a)$ where $i \in \set{1,2}$ and $a \in \ranked{\Sigma_i}$. The arity is inherited from $a$. 

The set of terms can be phrased in terms of tensor products and coproducts, as the least solution of the equation:
\begin{align*}
\tmonad \rSigma = \overbrace{\redset{\portletter}}^\text{port}  \ranked{+\coprod_{\black {a \in} \rSigma}} \overbrace{\ranked{\tmonad \rSigma \otimes \cdots \otimes \tmonad \rSigma}}^{\text{arity of $a$ times}}
\end{align*}  where $\ranked \coprod$ denotes possibly infinite coproduct.

\paragraph*{Folding.}
The final datatype constructor called \emph{folding}. Folding has two main purposes: (1) reordering ports in a term; and (2) reducing arities by grouping ports into groups. More formally, there is one unary constructor $\reduce k \rSigma$ for every $k \in \set{1,2,3,\ldots}$.  An $n$-ary element of $\reduce k \rSigma$, which is called a \emph{$k$-fold}, consists of an element      $a \in \rSigma$  together with an injective    \emph{grouping}  function
\begin{align*}
    f :  \text{ports of $a$} \to \underbrace{\set{1,\ldots,n} \times \set{1,\ldots,k} }_{\text{these pairs are called \emph{sub-ports}}}
\end{align*}
We denote such an element as $a/f$ and draw it like this: \mypic{53}
In the above picture there are $4 \times 3$ sub-ports.

Already for $k=1$, the constructor $\reduce 1$ is non-trivial. For example,  $\reduce 1 \tmonad \rSigma$ is a generalisation of terms where ports are not necessarily ordered left-to-right (because the grouping function need not be monotone), and some ports need not appear (because the grouping function need not be total); in other words this is the same as terms in the usual sense of universal algebra, with the restriction that each variable is used at most once (sometimes called linearity).

When viewed as a family of datatype constructors,  folds have a monad-like structure -- they are a graded  monad~\cite[p. 518]{fujiShinyaMellies2016}. The unit is the operation 
\mypic{98}
of type $\ranked{\Sigma \to \reduce 1 \Sigma}$, while  the product (or flattening) is the family of operations $\ranked{\reduce {k_2} \reduce {k_1} \Sigma \to \reduce {k_1 \cdot k_2} \Sigma}$, indexed by $k_1,k_2 \in \set{1,2,\ldots}$ that is illustrated in the following picture:
\mypic{99}
More formally, the flattening of two folds $(a/{f_1})/{f_2}$ has the grouping function defined
\begin{align*}
    % \label{eq:fold-grouping}
i \mapsto (i_2, \underbrace{(q_1 -1)k_2 + q_2}_{\substack{\text{bijection between} \\ \set{1,\ldots,k_1} \times \set{1\ldots,k_2} \\ \text{and $\set{1,\ldots,k_1k_2}$}}}) \qquad \text{where} \begin{cases}
    (i_1,p_1) &= f_1(i)\\
    (i_2,p_2) &= f_2(i_1)
\end{cases}
\end{align*}
% $k=2$, $n=4$, and $a$ has arity $a$. There  The groups are  and the arity of $a$ is 6, and $f$ is
% \begin{align*}
% \begin{array}{rccccccc}
%     i \in \set{1,\ldots,\arity a} &  \quad &1 & 2 & 3 & 4 & 5 & 6\\
%     \text{group of $f(i)$} &  & 1 & 1 & 4 & 2 & 3 & 4\\
%     \text{position of $f(i)$} & & 2 & 1 & 1 & 2 & 1 & 2 
% \end{array}
% \end{align*}
% A term has an arity, which is  the number of ports. Because the set of terms is itself a ranked set,  we can create terms of terms.  In fact, all of the datatypes and datatype constructors  work with ranked sets.


% A consequence of using terms is that we  work in the category of ranked sets; i.e.~our datatypes represent ranked sets and the functions we consider are arity-preserving functions between ranked sets.  As mentioned before, we use  red for ranked sets; we also use red  for operations that output ranked sets. 

%\footnote{This is a difference of trees as opposed to strings~\cite{bojanczykRegularFirstOrderList2018}, where ranked sets are not needed, because a part of a string is also a string.}
 
%
%
%The crucial property of the prime functions and  the combinators is that they use ranked sets. This is because the type constructor of this paper, namely terms, uses ranked sets.  Roughly speaking, a term is a tree with missing parts. The missing parts arise when we  isolate smaller parts of a bigger tree, as illustrated in the following picture:




%\begin{definition}[Terms]\label{def:terms}
%    An  term\footnote{
%        Our definition of terms differs from the definition used in universal algebra. An $n$-ary term in the sense of this paper is, in the language of universal algebra, a term over variables $\set{x_1,\ldots,x_n}$ where each variable appears exactly once, and the variables are used from left to right.  The requirement that variables appear  once is related to the linear output size of first-order tree-to-tree transductions. Without this requirement, even homomorphisms would have exponential output size. 
%    } over a ranked set $\rSigma$ is a tree over alphabet $\rSigma \redplus \redzero$, where $\redzero$ is a set with one element of arity zero.  The nodes with labels from $\redzero$  -- which are leaves --  are called \emph{ports}. The arity of a term is the number of ports.  We write $\tmonad \rSigma$ for the ranked set of terms over $\rSigma$.  
%\end{definition}




\paragraph*{Datatypes.} This completes the list of  datatype constructors. The datatypes are then defined by applying the constructors to the prime datatypes, which are either finite ranked sets (those with finitely many elements), or  the terminal ranked set (i.e.~a ranked set which admits a unique function from every other ranked set).
% We call such ranked sets \emph{types}.
%  The general idea is that we start with finite ranked sets, and close these under the following type constructors: coproducts, two kinds of product (Cartesian and tensor), taking terms, and a type constructor that allows to merge ports.
%  and the matrix power. 
% The  matrix power -- which is possibly the least natural type constructor -- will be motivated and discussed in more detail later on.



\begin{definition}[Datatypes] \label{def:types} A \emph{datatype} is any ranked set which can be obtained by applying the constructors 
    \begin{align*}
    \ranked{\tmonad \rSigma \qquad \rSigma_1 \otimes \rSigma_2 \qquad \rSigma_1 + \rSigma_2 \qquad \reduce k \rSigma},
    \end{align*}
    to ranked sets which are either finite or equal to the \emph{terminal ranked set}  defined by\footnote{The reason for this notation is that the terminal set can be used to model partial functions. A partial function of type  $\ranked{ \Sigma \to \Gamma}$ can be modelled as a total function of type $\ranked{\Sigma \to \Gamma + \termset}$, which outputs elements of $\termset$ instead of  undefined values.
    }
    \begin{align*}
    \termset \eqdef  \underbrace{\redset{\naryterm 0, \naryterm 1, \naryterm 2,\ldots}.}_{\substack{\text{for each arity $i$, one} \\ \text{element denoted by $i$}}}
    \end{align*}
\end{definition}


\subsection{Derivable functions}
\smallskip
\newcommand{\funcitem}[3]{\ranked{#1  } &:& \ranked{#2} \rto  \ranked{#3}}
This completes the definition of the datatype constructors. 
All datatype constructors are functors, in the sense  that  arity preserving functions
\begin{align*}
\ranked{f_1 : \Sigma_1 \to \Gamma_1 \qquad f_2 : \Sigma_2 \to \Gamma_2}
\end{align*}       
can be lifted, in the natural way, along the type constructors to new arity preserving  functions
\begin{eqnarray}
\label{eq:liftplus}\funcitem{f_1 + f_2}{\Sigma_1 + \Sigma_2}{\Gamma_1 + \Gamma_2} \\
\funcitem{\tensorpair{f_1,f_2}}{\Sigma_1 \otimes \Sigma_2}{\Gamma_1 \otimes \Gamma_2}\\
\funcitem{\reduce k f_1}{\reduce k \Sigma_1}{\reduce k \Gamma_1}\\
\label{eq:liftterm}
\funcitem{\tmonad f_1}{\tmonad \Sigma_1}{\tmonad \Gamma_1}
%\\\label{eq:liftshallow}\funcitem{\shallowterm{f_1}{f_2}}{\shallowterm{\Sigma_1}{\Sigma_2}}{\shallowterm {\Gamma_1}{\Gamma_2}} 
\end{eqnarray}

We now introduce the main new definition of this paper.

\begin{definition}[Derivable function]\label{def:derivable-function}
    The class of \emph{derivable} functions is the least class which contains:
    \begin{itemize}
    \item for every $\rSigma$, the unique arity preserving function $\ranked{\Sigma \to \termset}$;
    \item  all arity preserving functions with finite domain;
        \item  the prime functions in Figures~\ref{fig:monad},\ref{fig:product} and \ref{fig:not-explained};
         \end{itemize}
and which is closed under composition and  liftings (1)--(4).
\end{definition}

%\include{figure-fot}

The prime functions in Figure~\ref{fig:monad} describe the monad structure of terms and folds, and were explained in Section~\ref{sec:datatype-constructors}. The prime functions in Figure~\ref{fig:product} are  simple syntactic transformations, which are intended to have no computational content.  Figure~\ref{fig:not-explained} contains   less obvious operations, whose definitions are  deferred to Section~\ref{sec:prime-and-combinators}. Before giving these definitions, we state the main result of the paper. 

% \begin{example}
%     To get a feeling for the prime functions and combinators, we derive the function
%     \begin{align*}
%     \tensorpair{a,b} \in \ranked{\rSigma^2} \qquad \mapsto \qquad  \tensorpair{b,a} \in \ranked{\rSigma^2}
%     \end{align*}
%     which witnesses commutativity of the product for pairs of the same type. The idea is to embed pairs into terms, and use simple manipulations on terms. 
%     We  draw the unique elements of the sets $\redzero$, $\redone$ and $\redtwo$ as follows:
%     \mypic{79}
%     We begin by deriving a function which maps a tensor pair into a shallow term whose root is the unique element of $\redtwo$.  This is achieved by composing the derivable functions of types 
%     \begin{align*}
%     \ranked{
%         \xymatrix{
%             \rSigma \otimes \rSigma \ar[r] &
%             (\shallowterm \redone \rSigma) \otimes (\shallowterm \redone \rSigma) \ar[r] &
%             \shallowterm{(\redone \otimes \redone)}  {(\rSigma+\rSigma)} \ar[r] & \shallowterm \redtwo \rSigma
%         }
%     }
%     \end{align*}
%     which is described in the following picture:
%     \mypic{78}
%     The last function applies the bijection $\ranked{\redone \otimes \redone \to \redtwo}$, which is derivable by virtue of having a finite domain. 

%     Next, we can swap the children of 
% \end{example}

% We first observe that terms and unary folding are monads. 
% The monad structure for terms is induced by:
% \begin{align*}
%         \underbrace{\ranked {\tmonad f : \tmonad \Sigma \to \tmonad \Gamma}}_{\text{$\tmonad$ is a functor}} \qquad  \underbrace{\unit_\rSigma : \rSigma \rto \tmonad \rSigma}_{\text{the unit in the monad}} \qquad  \underbrace{\flatt_\rSigma : \tmonad \tmonad \rSigma \rto \tmonad \rSigma}_{\text{the product operation in the monad}},
% \end{align*}
% and a similar situation holds for unary folds $\reduce 1$.  More generally, the family of folds $\set{\reduce k}_{k}$ is a graded monad. Finally, the operation $\tmonad \reduce 1 \rSigma \rto \reduce 1 \tmonad \rSigma$ is a distributive law of these two monads.

% For a derivable function, its domain and co-domain are types as in Definition~\ref{def:types}, in particular the domain and co-domain are ranked sets. The prime functions are arity-preserving and the combinators preserve this property, and therefore all derivable functions are arity-preserving. 


% We are now ready to state the main theorem of this paper. 

\begin{theorem}\label{thm:main}
    Let $\rSigma,\rGamma$ be finite ranked sets. A function 
    \begin{align*}
        f : \trees \rSigma \to \trees \rGamma
    \end{align*}
    is a first-order tree-to-tree transduction if and only if it is the restriction to trees of some derivable
    \begin{align*}
        \ranked {f : \tmonad \Sigma \to \tmonad \Gamma}.
    \end{align*}
    
\end{theorem}

The bottom-up implication in the above theorem is proved by a straightforward induction on the derivation. We associate to each datatype a relational structure; for example the relational structure associated to a pair $\tensorpair {a_1,a_2}$ is the disjoint union of the relational structures associated to $a_1$ and $a_2$. These relational structures can then be transformed using first-order transductions.   We then show that all prime functions are first-order transductions (adapted suitably to structures other than trees); and that this property is preserved under applying the combinators.  This proof is in the appendix, and the rest of the paper is devoted to the top-down implication in the theorem, which says that every first-order transduction can be decomposed into the prime functions.
%\subsection{Proposition of another presentation of prime functions}
\input{functions-reduced}

%\input{functions}
\subsection{The prime functions from Figure~\ref{fig:not-explained}}
\label{sec:prime-and-combinators}
Before continuing with the proof of top-down implication in Theorem~\ref{thm:main}, we  describe the prime functions from Figure~\ref{fig:not-explained}. 
Each of these functions will play a key role in one of the main results of the paper.
%  We will highlight the moments when such functions are used.  


\subsubsection{Factorisations}
We begin with the factorisation functions 
\begin{align*}
    \overbrace{\ancfact}^{\text{ancestor}}, \overbrace{\decfact}^{\text{descendant}}  : \ranked{\tmonad(\Sigma_1+\Sigma_2) \to \tmonad(\tmonad \Sigma_1 + \tmonad \Sigma_2)}.
\end{align*}
Define a \emph{factorisation} of a term   to be any term of terms that flattens to it. 
% Another definition is that  a factorisation is an equivalence relation on non-port nodes where every equivalence class is a factor (connected via the parent-child relation). 
    % The two definitions are easily seen to be equivalent, in the sense that there is a one-to-one correspondence between factorisation in the two meanings.
    %  which is explained in the following picture:
    % \mypic{14}
The factorisation functions $\ancfact$ and $\decfact$ are used to transform a term  into a factorisations; with the partition of the input alphabet used to choose the factorisation.  Consider an input term $t \in \ranked{\tmonad(\rSigma_1 + \rSigma_2)}$.
        We say that two non-port nodes have \emph{same type} if both have labels in the same  $\ranked{\Sigma_i}$; otherwise we say that non-port nodes have \emph{opposing type}.  Call two non-port nodes \emph{ancestor equivalent}  if they have the same proper ancestors of opposing type. Call two non-port nodes \emph{descendant equivalent}  if they  are ancestor equivalent and they have the same proper descendants of opposing type. Here is a picture, with $\ranked{\Sigma_1}$ being red and $\ranked{\Sigma_2}$ being blue: 
        \mypic{111}
    %     \begin{center}
    %   \includegraphics[scale=.3]{facto-up-down.pdf}
    %     \end{center}
        For both of these equivalence relations, the equivalence classes are connected with respect to the parent-child relation, and therefore the equivalences can be seen as factorisations. Furthermore, the equivalence classes contain only nodes of same type.  The function $\ancfact$ maps a term to factorisation corresponding to its ancestor equivalence relation, likewise we define $\decfact$ for  descendant factorisations.
    
        \subsubsection{Pre-order traversal.} The preorder traversal function  
        \begin{align*}
            \ranked{\preorder : \tmonad \Sigma \to \reduce 1 \tmonad (\rSigma + 0 + 2)}
        \end{align*}
        is the natural extension -- from trees to terms -- of the depth-first traversal, as explained below (the nullary grey nodes represent the labels from $\ranked 0$, and the binary grey nodes represent the labels from $\ranked 2$):
        \begin{center}
        \includegraphics[scale=.34]{pictures/preorder.pdf}
        \end{center}
The $\preorder$ function respects the input port order, this is the reason  why we have a fold $\reduce 1$ in the output type. 

\input{unfold}
%\subsubsection{Unfolding}
%The general idea behind the  unfolding operation 
%\begin{align*}
%\ranked{
%    \unfoldsmall : \shallowterm {(\reduce k   \Sigma)} {\Gamma^k} \to \reduce 1 (\shallowterm \Sigma \Gamma)
%}
%\end{align*} 
%is to eliminate a $k$-fold by matching it with a $k$-th power. 
%The unfolding operation is explained in the following picture for $k=2$: 
%        \begin{center}
%        \includegraphics[scale=.36]{shallow-unfold.pdf}
%        \end{center}


% One of the main results in this paper will be  that an iterated version of the unfold operation, of type
% \begin{align*}
% \ranked{    \tmonad (\reduce k \Sigma^k) \to \reduce k (\tmonad \Sigma)^k,}
% \end{align*}
% can be derived from the other operations. 

% The formal definition is 
% \begin{align*}
% (a/f) \tensorpair{\tensorpair{b_{1,1},\ldots,b_{1,k}},\ldots,\tensorpair{b_{n,1},\ldots,b_{n,k}}} \qquad \mapsto \qquad 
% (a\tensorpair{b_{f(1)},\ldots,b_{f(\arity a)}})/g
% \end{align*}
% where $g$ is defined so that it matches ...


