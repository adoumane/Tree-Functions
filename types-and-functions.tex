\section{Derivable functions}
In this section, we present the main result of this paper, which says that the  first-order tree-to-tree functions are exactly those which can be derived from certain atomic functions by using certain combinators.  A typical combinator is composition of functions.

\paragraph*{The category of ranked sets.}
The crucial property of the atomic functions and  the combinators is that they use ranked sets. The reason is that the central data structure used in this paper, namely terms, is a ranked set.  Roughly speaking, a term is a tree with missing parts. The missing parts arise when we  isolate smaller parts of a bigger tree, as illustrated in the following picture:
\mypic{15}
This is a difference of trees as opposed to strings~\cite{bojanczykRegularFirstOrderList2018}, because factors of strings are also strings.


\begin{definition}[Terms]\label{def:terms}
    An  term\footnote{
        Our definition of terms differs from the definition used in universal algebra. An $n$-ary term in the sense of this paper is, in the language of universal algebra, a term over variables $\set{x_1,\ldots,x_n}$ where each variable appears exactly once, and the variables are used from left to right.  The requirement that variables appear  once is related to the linear output size of first-order tree-to-tree transductions. Without this requirement, even homomorphisms would have exponential output size. 
    } over a ranked set $\rSigma$ is a tree over alphabet $\rSigma \redplus \redzero$, where $\redzero$ is a set with one element of arity zero.  These nodes -- which are leaves --  are called \emph{ports}. The arity of a term is the number of ports.  We write $\tmonad \rSigma$ for the ranked set of terms over $\rSigma$.  
\end{definition}



Because the set of terms is itself a ranked set,  we can create terms of terms.         A consequence of using terms is that we will work in the category of ranked sets; i.e.~the types we use will be ranked sets and the functions we consider are arity-preserving functions between ranked sets. We adopt the notation that arity-preserving functions are written in red, like this: $\ranked{f : \Sigma \to \Gamma}$. 

\paragraph*{Types.} The following definition describes the  ranked sets that will be allowed as domains and co-domains of our functions, we call such ranked sets \emph{types}.
%  The general idea is that we start with finite ranked sets, and close these under the following type constructors: coproducts, two kinds of product (Cartesian and tensor), taking terms, and a type constructor that allows to merge ports.
%  and the matrix power. 
% The  matrix power -- which is possibly the least natural type constructor -- will be motivated and discussed in more detail later on.



\begin{definition}[Types] \label{def:types} Every  ranked set with finitely many elements is a type. Furthermore, types are closed under the following type constructors:
    \begin{enumerate}
       \item \emph{Coproduct.} An element of the \emph{coproduct} $\ranked{\Sigma_1 + \Sigma_2}$ is a co-pair of the form  $(i,a)$ where $i \in \set{1,2}$ and $a \in \ranked{\Sigma_i}$. The arity is inherited from $a$. We draw co-pairs like this:
       \mypic{61}
              \item       \emph{Product.} An element of the   \emph{product}\footnote{
                  A more precise name would be \emph{tensor product}. The alternative product, call it \emph{Cartesian product}, would have as $n$-ary elements  pairs $(a_1,a_2)$ such that both $a_1$ and $a_2$ have arity $n$. Since we do not use Cartesian product, we write product without specifying that we mean the tensor product.
              } $\ranked{\Sigma_1 + \Sigma_2}$  is a  pair $\tensorpair{a_1,a_2}$ where $a_i \in \ranked{\Sigma_i}$. The arity   is the sum of arities of $a_1$ and $a_2$. We draw pairs like this:
        \mypic{52}
        \item \emph{Folding.} For every $k \in \set{1,2,3,\ldots}$, we have a unary type constructor $\reduce k \rSigma$  which is used to reduce arities, by grouping ports into groups of size at most $k$.  An $n$-ary element of $\reduce k \rSigma$ consists of an element      $a \in \rSigma$  together with an  injective  function
            \begin{align*}
                f : \set{1,\ldots,\arity a} \to \set{1,\ldots,k} \times  \set{1,\ldots,n}.
            \end{align*}
            We denote such an element as $a/f$, and we draw it like this: \mypic{53}
        \item \emph{Terms.} The term type constructor $\tmonad \rSigma$ has already been discussed at the beginning of this section. This is the only type constructor that does not preserve finiteness. We draw terms like this:
        \mypic{51}
        \item \emph{Shallow terms.} The  ranked set $\shallowterm \rGamma \rSigma$ of  \emph{shallow terms} is defined as
        \begin{align*}
            \ranked {\shallowterm \rSigma \rGamma \eqdef \coprod_{a \in \rSigma} \rGamma^{\text{arity of $a$}}}.
        \end{align*}
        The coproduct in the above definition is infinite when $\rSigma$ is infinite. 
        An equivalent definition is that a shallow term  is the special case of  a term over $\rSigma \redplus \rGamma$ where  the root has label from $\rSigma$, all children have labels  from $\rGamma$, and all grand-children are ports. We draw shallow terms like terms:
        \mypic{76}
    \end{enumerate}
\end{definition}


\newcommand{\funcitem}[3]{\ranked{#1  } &:& \ranked{#2} \rto  \ranked{#3}}
All of the type constructors  above are functors, in the sense  that  arity preserving functions
\begin{align*}
\ranked{f_1 : \Sigma_1 \to \Gamma_1 \qquad f_2 : \Sigma_2 \to \Gamma_2}
\end{align*}       
can be lifted along the type constructors to new functions
\begin{eqnarray}
\label{eq:liftplus}\funcitem{f_1 + f_2}{\Sigma_1 + \Sigma_2}{\Gamma_1 + \Gamma_2} \\
\funcitem{(f_1,f_2)}{\Sigma_1 \otimes \Sigma_2}{\Gamma_1 \otimes \Gamma_2}\\
\funcitem{\reduce k f_1}{\reduce k \Sigma_1}{\reduce k \Gamma_1}\\
\funcitem{\tmonad f_1}{\tmonad \Sigma_1}{\tmonad \Gamma_1}\\
\label{eq:liftshallow}\funcitem{\shallowterm{f_1}{f_2}}{\shallowterm{\Sigma_1}{\Sigma_2}}{\shallowterm {\Gamma_1}{\Gamma_2}} 
\end{eqnarray}

We now introduce the main new definition of this paper.

\begin{definition}[Derivable function]
    The class of \emph{derivable} functions is the least class which:
    \begin{itemize}
        \item contains the atomic functions in Figure~\ref{fig:fo-term} and all arity-preserving functions with finite domain;
        \item is closed under  function composition and the liftings~\eqref{eq:liftplus}-\eqref{eq:liftshallow}.
    \end{itemize}
\end{definition}

\include{figure-fot}

Some of the definitions of the atomic functions from Figure~\ref{fig:fo-term} are deferred to Section~\ref{sec:atomic-and-combinators}. Before giving these definitions, we discuss some of the functions that are already defined, and state the main result of the paper. 

We first observe that terms and unary folding are monads. 
The monad structure for terms is induced by:
\begin{align*}
        \underbrace{\ranked {\tmonad f : \tmonad \Sigma \to \tmonad \Gamma}}_{\text{$\tmonad$ is a functor}} \qquad  \underbrace{\unit_\rSigma : \rSigma \rto \tmonad \rSigma}_{\text{the unit in the monad}} \qquad  \underbrace{\flatt_\rSigma : \tmonad \tmonad \rSigma \rto \tmonad \rSigma}_{\text{the product operation in the monad}},
\end{align*}
and a similar situation holds for unary folds $\reduce 1$.  More generally, the family of folds $\set{\reduce k}_{k}$ is a graded monad. Finally, the operation $\tmonad \reduce 1 \rSigma \rto \reduce 1 \tmonad \rSigma$ is a distributive law of these two monads.

% For a derivable function, its domain and co-domain are types as in Definition~\ref{def:types}, in particular the domain and co-domain are ranked sets. The atomic functions are arity-preserving and the combinators preserve this property, and therefore all derivable functions are arity-preserving. 


% We are now ready to state the main theorem of this paper. 

\begin{theorem}\label{thm:main}
    Let $\rSigma,\rGamma$ be finite ranked sets. A function 
    \begin{align*}
        f : \trees \rSigma \to \trees \rGamma
    \end{align*}
    is a first-order tree-to-tree transduction if and only if it is the restriction to trees of some derivable
    \begin{align*}
        \ranked {f : \tmonad \Sigma \to \tmonad \Gamma}.
    \end{align*}
    
\end{theorem}




\subsection{The atomic functions not explained in Figure~\ref{fig:fo-term}}
\label{sec:atomic-and-combinators}
In this section, we define the atomic functions whose definitions were not given in Figure~\ref{fig:fo-term}. 




\subsubsection{Factorisations}
    Let $t \in \tmonad \rSigma$ be a term. 
    There are two equivalent definitions of factorisations of $t$. One definition is that a factorisation is an equivalence relation on non-port nodes where every equivalence class is a factor; the other definition is that it is any term $s  \in \tmonad \tmonad \rSigma$ which flattens to $t$. 
    The two definitions are easily seen to be equivalent, in the sense that there is a one-to-one correspondence between factorisation equivalences and factorisation terms.
    %  which is explained in the following picture:
    % \mypic{14}
    Suppose that $\ranked{\Sigma_1}$ and $\ranked{\Sigma_2}$ are ranked sets. The ancestor and descendant factorisations 
        \begin{align*}
            \overbrace{\ancfact}^{\text{ancestor}}, \overbrace{\decfact}^{\text{descendant}}  : \ranked{\tmonad(\Sigma_1+\Sigma_2) \to \tmonad(\tmonad \Sigma_1 + \tmonad \Sigma_2)}
        \end{align*}
        are defined as follows. Consider an input term
        \begin{align*}
            t \in \ranked{\tmonad(\Sigma_1+\Sigma_2)}.
        \end{align*}
        We say that two non-port nodes have \emph{same type} if both have labels in the same  $\ranked{\Sigma_i}$; otherwise we say that non-port nodes have \emph{opposing type}.  Call two non-port nodes \emph{ancestor equivalent}  if they have the same proper ancestors of opposing type. Call two non-port nodes \emph{descendant equivalent}  if they  are ancestor equivalent and they have the same proper descendants of opposing type. Here is a picture, with $\ranked{\Sigma_1}$ being red and $\ranked{\Sigma_2}$ being blue: \todo{les images ne collent pas avec la def.}
        \mypic{11}
        Both ancestor and descendant equivalences are factorisations; and in each case equivalence classes contain only nodes of same type.  The function $\ancfact$ maps a term to (the term of terms corresponding to) its ancestor equivalence relation, likewise we define $\decfact$ for  descendant factorisations.
    
        \subsubsection{Pre-order traversal.} The preorder traversal function  
        \begin{align*}
            \ranked{\preorder : \tmonad \Sigma \to \reduce 1 \tmonad (\rSigma + 0 + 2)}
        \end{align*}
        is the natural extension -- from trees to terms -- of the  pre-order function discussed in Example~\ref{ex:pre-order}, as explained below (the unary grey nodes represent the labels from $\ranked 0$, and the binary grey nodes represent the labels from $\ranked 2$):
        \mypic{13}
        
\subsubsection{Unfolding}
The general idea behind the  unfolding operation 
\begin{align*}
\ranked{
    \unfoldsmall : \shallowterm {(\reduce k   \Sigma)} {\Gamma^k} \to \reduce 1 (\shallowterm \Sigma \Gamma)
}
\end{align*} 
is to eliminate a $k$-fold by matching it with a $k$-th power. 
The unfolding operation is explained in the following picture for $k=3$:
\mypic{56}
% One of the main results in this paper will be  that an iterated version of the unfold operation, of type
% \begin{align*}
% \ranked{    \tmonad (\reduce k \Sigma^k) \to \reduce k (\tmonad \Sigma)^k,}
% \end{align*}
% can be derived from the other operations. 

% The formal definition is 
% \begin{align*}
% (a/f) \tensorpair{\tensorpair{b_{1,1},\ldots,b_{1,k}},\ldots,\tensorpair{b_{n,1},\ldots,b_{n,k}}} \qquad \mapsto \qquad 
% (a\tensorpair{b_{f(1)},\ldots,b_{f(\arity a)}})/g
% \end{align*}
% where $g$ is defined so that it matches ...