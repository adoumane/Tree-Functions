\section{First-order term functions}
The goal of this paper is to characterise the first-order tree-to-tree functions in terms of some atomic functions and combinators which produce new functions from previously defined ones. A typical combinator is composition of functions.

\subsection{Terms}
For our purposes, the datatype of trees will be insufficient, because  we will need a generalisation of trees where some leaves  are ports   where other trees can be substituted. We use the name \emph{terms} for this generalisation. Fix a set of variables
\begin{align*}
    \termvars = \set{x_1,x_2,\ldots}
\end{align*}
which will be assumed to be disjoint with all other sets.  We view the variables as a ranked set, where each variable has arity zero, i.e.~it can only be used in leaves. 

\begin{definition}[Terms]\label{def:terms}
    An $n$-ary term over a ranked set $\rSigma$ is defined to be a tree over the ranked alphabet $\rSigma + \termvars$ where each variable from $x_1,\ldots,x_n$ appears exactly once, in left-to-right order,  and the other variables do not appear at all.    We write $\tmonad \rSigma$ for the ranked set of terms over $\rSigma$. 
\end{definition}

We adopt the following convention for drawing terms. The term is drawn inside a box, and the dangling edges which leave the box at the bottom are its variables, ordered left-to-right, as in the following picture: \mypic{7}
% If we disallow crossing edges in the pictures, then the above drawing convention can only represent terms where the variables are ordered $x_1,\ldots,x_n$ from left to right. 
 The restriction that each variable appears exactly one, sometimes called \emph{linearity}, is connected to the fact that first-order transductions have linear size increase. Because the set of terms is itself a ranked set,  we can create terms of terms, which will be useful in the constructions of this paper. 

To see the need for terms, suppose that we want to group the nodes of a tree into connected parts, called factors. Then the factors are not trees, because they have dangling edges, but they can be viewed as terms, as explained in the following picture:
\mypic{15}
        
A consequence of using terms is that we will work in the category of ranked sets; i.e.~the types we use will be ranked sets and the functions we consider are arity-preserving functions between ranked sets. We adopt the notation that arity-preserving functions are written in red, like this: $\ranked{f : \Sigma \to \Gamma}$. 


\subsection{Types}
The  main goal of this paper is to  describe first-order tree-to-tree functions using a certain atomic functions and combinators on them. These functions will be arity preserving functions on ranked sets. In this section, we describe the kinds of ranked sets that will be allowed as domains and co-domains of our functions. The general idea is that we start with finite ranked sets, and close these under the following type constructors: coproducts, two kinds of product (Cartesian and tensor), taking terms, and the matrix power. 
The  matrix power -- which is possibly the least natural type constructor -- will be motivated and discussed in more detail later on.


\begin{definition}[Types] \label{def:types} The following ranked sets are called \emph{types}:
    \begin{enumerate}
        \item  \emph{Finite ranked sets.} Every finite  ranked set is a type. (A finite ranked set is one that  has finitely many elements altogether, in particular only finitely many arities are represented.)
        \item \emph{Coproduct.} If $\ranked{\Sigma_1}$ and $\ranked{\Sigma_2}$ are types, then  their \emph{coproduct} $\ranked{\Sigma_1 + \Sigma_2}$
        is also a type. An $n$-ary element of the coproduct is a pair $(i,a)$ where $i \in \set{1,2}$ and $a$ is an $n$-ary element of  $\ranked{\Sigma_i}$. 
        \item \emph{Cartesian product.} If $\ranked{\Sigma_1}$ and $\ranked{\Sigma_2}$ are types, then  their \emph{Cartesian product}
        $ \ranked{\Sigma_1 \times \Sigma_2}$
        is also a type. An $n$-ary element of the Cartesian product is a pair $(a_1,a_2)$ such that $a_i \in \ranked{\Sigma_i}$ and 
        \begin{align*}
            n = \arity{a_1} = \arity{a_2}.
        \end{align*}
        \item \emph{Tensor product.} If $\ranked{\Sigma_1}$ and $\ranked{\Sigma_2}$ are types, then  their \emph{tensor product}
        $ \ranked{\Sigma_1 \otimes \Sigma_2}$
        is also a type. An $n$-ary element of the Cartesian product is a pair $\tensorpair{a_1,a_2}$ such that $a_i \in \ranked{\Sigma_i}$ and 
        \begin{align*}
            n = \arity{a_1} + \arity{a_2}.
        \end{align*}
        Note how we use  angular brackets to distinguish tensor $\tensorpair{a_1,a_2}$ pairs from Cartesian pairs $(a_1,a_2)$.
        \item \emph{Terms.} If $\ranked \Sigma$ is a type, then  the ranked sets of terms  $\tmonad \rSigma$ is also a type.
       \item \emph{Matrix power.}  If  $\rSigma$ is a type and $k \in \set{1,2,\ldots}$, then the \emph{$k$-th matrix power of $\rSigma$}, denoted by $\ranked{\Sigma^{[k]}}$, is also a type.  An $n$-ary element of $\ranked{\Sigma^{[k]}}$ is a (tensor) tuple
       \begin{align*}
           \tensorpair{a_1,\ldots,a_k} \in \overbrace{\ranked{\Sigma \otimes \cdots \otimes \Sigma}}^{\text{$k$ times}} 
       \end{align*}
       of arity $kn$ (note the difference between the arities $n$ and $kn$), together with a function
       \begin{align*}
           f : \set{1,\ldots,kn} \to \set{1,\ldots,n} \qquad \text{such that $f^{-1}(i)$ has size exactly $k$ for every $i$.}
       \end{align*}
       Here is a picture of an $n$-ary element of  $\ranked{\Sigma^{[2]}}$ for $n=3$ and $k=2$:
       \mypic{16}
    \end{enumerate}
\end{definition}

\subsection{The main result}
In this section, we state the main result of this paper, which is that every first-order tree-to-tree function can be obtained by starting with certain simple functions and combining them using combinators. The atomic functions and combinators are listed in Figure~\ref{fig:fo-term}. Their precise definitions, along with some justification for their use,   will be given in more detail in Section~\ref{sec:atomic-and-combinators}.

Many of the operations are very natural given their underlying types, e.g.~we include constructors and destructors that are usually associated to products and coproducts, we also have various kinds of distributivity laws (e.g.~both products distribute across coproducts). Several operations for  the type of terms arise from the fact that the term construction is a monad. There are, however, some operations which require more explanation; the same is true also for the matrix power construction. 

\begin{definition}
    A \emph{first-order term function} is any function that can be constructed using the atomic functions and combinators described in Figure~\ref{fig:fo-term}.
\end{definition}

Since all atomic functions are arity preserving functions between types (as per Definition~\ref{def:types}), and the combinators preserve this property, it follows that all first-order term functions are arity preserving functions between types. We are now ready to state the main theorem of this paper. 

\begin{theorem}
    Let $\rSigma,\rGamma$ be finite ranked sets. A function 
    \begin{align*}
        f : \trees \rSigma \to \trees \rGamma
    \end{align*}
    is a first-order tree-to-tree transduction if and only if it can be obtained by taking a first-order term function
    \begin{align*}
        \ranked {g : \tmonad \Sigma \to \tmonad \Gamma}
    \end{align*}
    and restricting it to trees (i.e.~terms of arity zero).
\end{theorem}


\include{figure-fot}





