
\section{The atomic functions and combinators for terms}
\label{sec:atomic-and-combinators}
In this section, we define the atomic functions and combinators from Figure~\ref{fig:fo-term} which involve the term type constructor $\tmonad$. 





\subsection{Terms as an algebraic data type} Let $\ranked \Sigma$ be a ranked set. If $a \in \Sigma$ is a letter of arity $n$, and $t_1,\ldots,t_n$ are terms in $\tmonad \rSigma$, then also 
\begin{align*}
    a \tensorpair{t_1,\ldots,t_n}
\end{align*}
is a term, which has $a$ in the root and child subterms $t_1,\ldots,t_n$. We use the tensor brackets $\tensorpair{t_1,\ldots,t_n}$ because the arity of the term is the sum of the arities of $t_1,\ldots,t_n$, as in the tensor product. Another way of constructing a term is to simply have a port $\portletter$ in the root. The above observations explain the function 
\begin{align*}     
    \set * + \coprod_{a \in \Sigma} \overbrace{\tmonad \rSigma \otimes \cdots \otimes \tmonad \rSigma}^{\text{arity of $a$ times}}   \qquad \ranked{\xymatrix{
        \ar[r]^{\composeterm}& 
        %  \ar@<.5ex>[l]^{\composeterm} 
    }} \qquad \tmonad \rSigma
\end{align*}
from Figure~\ref{fig:fo-term}. Note that the coproduct above can only be viewed as a legitimate type when $\rSigma$ is finite; and therefore the function $\composeterm$ is only allowed when $\rSigma$ is finite. The function $\composeterm$ is not injective but not surjective, because its image will contain only the terms that satisfy condition (*) explained in the following picture: 
\mypic{28}
If we assumed, in definition~\ref{def:terms}, that the variables in a term are ordered left-to-right, then $\composeterm$ would be a bijection. The operation 
\begin{align*}     
    \set {\bot,*} + \coprod_{a \in \Sigma} \overbrace{\tmonad \rSigma \otimes \cdots \otimes \tmonad \rSigma}^{\text{arity of $a$ times}}   \qquad \ranked{\xymatrix{
&          \ar[l]^{\decomposeterm} 
    }} \qquad \tmonad \rSigma
\end{align*}
is a one-sided inverse of $\composeterm$, i.e.~it is output is the inverse of $\composeterm$ for terms that satisfy (*) and otherwise it is $\bot$. 


\subsection{Terms as a monad.} Three of the operations associated to the type constructor $\tmonad$, namely  
\begin{align*}
        \underbrace{\ranked {\tmonad f : \tmonad \Sigma \to \tmonad \Gamma}}_{\text{$\tmonad$ is a functor}} \qquad  \underbrace{\unit_\rSigma : \rSigma \rto \tmonad \rSigma}_{\text{the unit in the monad}} \qquad  \underbrace{\flatt_\rSigma : \tmonad \tmonad \rSigma \rto \tmonad \rSigma}_{\text{the product operation in the monad}}
\end{align*}
induce a monad structure on terms (in the category of ranked sets). The lifting $\tmonad f$ should be self-explanatory: one simply changes the labels in the term according to $f$. The  unit operation interprets each letter as a term with one non-variable node, with the variables ordered left-to-right,  as illustrated below:
        \mypic{10}
Finally, the  \emph{flattening} operation $\flatt_\rSigma$ 
        maps a term of terms into a term, by using substitution as illustrated in the following picture:  \mypic{9}
% A more formal definition is the flattening of $\portletter$ is $\portletter$, while the flattening of a term of the form 
% \begin{align*}
%     t \tensorpair{t_1,\ldots,t_n} \qquad t \in \tmonad \rSigma, t_1,\ldots,t_n \in \tmonad \tmonad \rSigma    
% \end{align*}
%  is the term obtained by taking $t$, and replacing each port $x_i$ by the flattening of $t_i$.
    
\subsection{Factorisations}
    Let $t \in \tmonad \rSigma$ be a term. 
    There are two equivalent definitions of factorisations of $t$. One definition is that a factorisation is an equivalence relation on non-port nodes where every equivalence class is a factor; the other definition is that it is any term $s  \in \tmonad \tmonad \rSigma$ which flattens to $t$. 
    The two definitions are easily seen to be equivalent equivalent, in the sense that there is a one-to-one correspondence between factorisation equivalences and factorisation terms.
    %  which is explained in the following picture:
    % \mypic{14}
    Suppose that $\ranked{\Sigma_1}$ and $\ranked{\Sigma_2}$ are ranked sets. The ancestor and descendant factorisations 
        \begin{align*}
            \overbrace{\ancfact}^{\text{ancestor}}, \overbrace{\decfact}^{\text{descendant}}  : \ranked{\tmonad(\Sigma_1+\Sigma_2) \to \tmonad(\tmonad \Sigma_1 + \tmonad \Sigma_2)}
        \end{align*}
        are defined as follows. Consider an input term
        \begin{align*}
            t \in \ranked{\tmonad(\Sigma_1+\Sigma_2)}.
        \end{align*}
        We say that two non-port nodes have \emph{same type} if both have labels in the same  $\ranked{\Sigma_i}$; otherwise we say that non-port nodes have \emph{opposing type}.  Call two non-port nodes \emph{ancestor equivalent}  if they  same proper ancestors of opposing type. Call two non-port nodes \emph{descendant equivalent}  if they  are ancestor equivalent and they have the same proper descendants of opposing type. Here is a picture, with $\ranked{\Sigma_1}$ being red and $\ranked{\Sigma_2}$ being blue:
        \mypic{11}
        Both ancestor and descendant equivalences are factorisations; and in each case equivalence classes contain only nodes of same type.  The function $\ancfact$ maps a term to (the term of terms corresponding to) its ancestor equivalence relation, likewise we define $\decfact$ for  descendant factorisations.
    
        \subsection{Pre-order traversal.} Let  $\rSigma$ be a ranked set. Let \grayball and \grayballbin be two letters, of arities zero and two. Define 
        \begin{align*}
            \ranked{\preorder : \tmonad \Sigma \to \tmonad (\rSigma + \set{\grayball, \grayballbin})}
        \end{align*}
        to be the extension to  terms of the pre-order function discussed in Example~\ref{ex:pre-order}, as explained below:
        \mypic{13}
        

