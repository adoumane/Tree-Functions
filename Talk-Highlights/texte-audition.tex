\documentclass{article}
\usepackage{listings}
\usepackage{etex}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{array}
\usepackage{url}
\usepackage{cmll}
\usepackage{amsmath}
\usepackage{sansmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathdots}
\usepackage{wasysym,stmaryrd}
\usepackage{marvosym}
\usepackage[T1]{fontenc}
\usepackage{ebproof}
\usepackage[all]{xy}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{cjhebrew}
\usepackage{cmll}	
\usepackage{mathpartir}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning,automata,shadows,calc,shapes}
\usepackage{rotating}
\usepackage{chngpage}
\usepackage{mathrsfs}
\usepackage[justification=centering,labelfont=bf]{caption}
\usepackage{geometry}
\geometry{hmargin=2.3cm,vmargin=3.1cm}
%\setlength{\oddsidemargin}{2pt} % Marge gauche sur pages impaires
%\setlength{\evensidemargin}{2pt} % Marge gauche sur pages paires
\usepackage{hyphenat}
\usepackage{etex}
\usepackage{xcolor}
\usepackage{framed} %barres vertivales
\usepackage{blindtext} %lorem ipsum
\usepackage{multicol} %colonnes
\usepackage{wrapfig} %figures entourées de texte
\usepackage{todonotes}
\presetkeys{todonotes}{fancyline, color=orange}{}
\usepackage{lscape}
\usepackage{rotating}
\usepackage{dsfont}
\usepackage{stmaryrd}
\usetikzlibrary{patterns}
%\usepackage{bclogo}
%\usepackage[pstricks]{bclogo}
\usepackage[tikz]{bclogo}

\input{macros}
%pour cacher les todo, décommenter la ligne ci-dessous
%\renewcommand{\todo}[2][]{}



\title{Completeness for identity free Kleene Lattices }

\author{
  Amina Doumane
}

\lstdefinestyle{base}{
 % language=C,
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{red}]{@}{@},
}


\begin{document}

\maketitle
\section{Motivation}
\begin{itemize}
\item I will start by giving some motivations for this work, although I dont think it is really necesary for this audience. 
\item  The motivtion for this work comes from the task of verification of imperative programs. These programs are lists of instructions. A pleasant way to think about each of these atomic instructions is a relations which transforms the memory states. For instance, the first command can be seen as a relation calle it a, etc... And the whole program can be seen as the composition of these relations.
\item Now, suppose that we have two imperative programs, and suppose that we want to check if they have the same behaviour. For insatnce let us take the program $x \leftarrow 1; ((y \leftarrow x) + (y \leftarrow 0))$ and
$(x \leftarrow 1; y \leftarrow x) + (x \leftarrow 1; y \leftarrow 0)$.

\item To check that two programs have the same behaviour, one possible way to proceed is to abstract these instructions into relations (here a, b and c) and check that the obtained expressions are equal in the relational model. This means that no matter how we chose to interpret a, b, c as relations, the equation still hold. If this is the case, we can be sure that the two programs have the same behaviour.

\item  In this example, I used relations composion and union to simulate programs composition and non-deterministic choice. But depending on the class of programs under consideration, we may need other operators, for instance transitive closure to simulate while loop, (et les autres? ) 

\item In this presentation I will focus on two classes of operators: the first one is the set of KA operators. If we look at the expressions generated by these operations we get regular expressions. This class of operators is very standard, and will serve as a reference point.
The second class of operators are the KLm operators. It contains the operators of KA except the identity(1) together with the intersection operator. And I introduce it because my completness result will be about this fragment.  

\item Here is an example of a valid law in KLm. Note that in the first law I considered the equality relation, while I considered inclusion in the second one. Both are interesting.
  
\item To use this relational semantics in verification, one should obtain two propetries. The first is decidability of the relational equivalence of two expressions e and f, and the second is its axiomatisatbility. Decidability makes it possible to automate the verification process, while axiomatizability provides a certificate for programs
verification. Indeed, an axiomatic proof of e = f can be seen as a certificate, which can
be exchanged, proofread, and combined in a modular way. 

\item Here is a summary of the situation of the KA and KL fragments. We know that the equational theory of KA is decidable, it is even PSPACE-complete,  it admits a finite axiomatisation which is just the axioms of Kleene Algebra.

\item We know also that KL is EXPSPACE complete.  
What is missing to this picture is an axiomatisation of KL. 

\end{itemize}

\end{document}
