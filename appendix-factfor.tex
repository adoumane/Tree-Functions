\section{The matrix power}
\label{ap:matrix-power}
\newcommand{\treeunfold}{\mathrm{unfold}}

\subsection{The need for monotonicity in the unfold operation}

\begin{example}\label{eq:twist}
    Consider the following elements in a second matrix power:
\begin{center}
\includegraphics[scale=.3, page=84]{pics.pdf}
\end{center}
Let $t_n \in \trees \mati 2 \rSigma$ be the tree which consists of a path with $n$ nodes using the unary label $a$, followed by a leaf with label $b$. If we apply term unfolding to this tree, and then project to the first coordinate, then we get a tree with a white leaf if and only if  $n$ is even.  If term unfolding were derivable, then thanks to the results from Section~\ref{sec:to-transductions}  we would get a first-order tree-to-tree transduction 
\begin{align*}
\trees \redset{a,b} \to \trees \rSigma
\end{align*}
where the output would contain a white leaf if and only if the input has odd depth. This is in turn would imply that having even depth for trees over $\redset{a,b}$ is first-order definable, which it is not, because first-order logic cannot do modulo counting.
\end{example}
The problem in the above example is that the letter $a$ does a swap on its ports, which leads to counting modulo two. To forbid such swaps, we impose a monotonicity requirement that matches the monotonicity requirement for register updates in register transducers.

\subsection{Proof of Proposition~\ref{prop:monotone-unfold}}
This part of the appendix is devoted to proving Proposition~\ref{prop:monotone-unfold}, which says that  for  every finite ranked set $\rSigma$ and every $k \in \set{1,2,\ldots}$ there is a derivable function 
    \begin{align*}
    \ranked{ f : \tmonad \mati k \Sigma \to \mati k {(\tmonad \Sigma)}}
    \end{align*}
    which coincides with term unfolding for monotone inputs.


Our proof strategy is to show that term unfolding can be derived for certain homogeneous (see below) monotone inputs, and then to show that every input can be decomposed into simpler inputs in a homogeneous way. The notion of homogeneous inputs, and the result about  decomposing of arbitrary inputs into homogeneous inputs, are presented in Section~\ref{sec:factfor}. Next, in Section~\ref{sec:homo-unfold}, we show how term unfolding can be done for homogeneous inputs. Finally, in Section~\ref{sec:monotone-unfold-proof} we prove Proposition~\ref{prop:monotone-unfold} by combining  the results of Sections~\ref{sec:factfor} and~\ref{sec:homo-unfold}.

\input{factfor}
\input{homo-unfold}

\subsection{Proof of Proposition~\ref{prop:monotone-unfold}}
\label{sec:monotone-unfold-proof}
In this section, we complete the proof of Proposition~\ref{prop:monotone-unfold}.  We say that a nested factorisation in $\tmonadn n \mati k \rSigma$ is \emph{monotone} if all of the labels from $\mati k \rSigma$ that appear in it are monotone. 
Consider the homomorphism which maps a branch to its corresponding twist, and which gives the completely undefined function in case the twist is not monotone.  The homomorphism uses an aperiodic monoid, as discussed in Example~\ref{ex:partial-monoton-functions}. 
 Apply the Factorisation Forest Theorem with respect to this homomorphism, yielding a derivable function
\begin{align*}
\ranked{ f : \tmonad \mati k \rSigma \to \tmonadn n \mati k \rSigma}
\end{align*}
which produces only nested factorisations that are  hereditarily homogeneous. (Also, because monotone functions are closed under composition, it follows that if  an input to $\ranked f$ is monotone, then the same is true for the output.) Therefore,  Proposition~\ref{prop:monotone-unfold} follows by composing the function $\ranked f$ with the function $\ranked {g_n}$ from the following lemma. 

\begin{lemma}\label{lem:ind-homo-twist}
    For every finite ranked set $\rSigma$ and  $n \in \set{1,2,\ldots}$ there is a derivable function
    \begin{align*}
    \ranked{ g_n : \tmonadn n \mati k \rSigma \to \mati k \tmonad \rSigma}
    \end{align*}
    which makes the following diagram commute for inputs that are  monotone and  hereditarily homogeneous: 
    \begin{align*}
        \ranked{
            \xymatrix{
                \tmonadn n \mati k\rSigma \ar[d]_{\flatn n} \ar[rd]^g\\
                \tmonad  \mati k \rSigma \ar[r]_{\unfold}& \mati k \tmonad \rSigma 
            }
        }
    \end{align*}
\end{lemma}
\begin{proof}
    Induction on $n$. To make the induction pass through, we also show that each function $\ranked{g_n}$ is consistent wit the  twist homomorphism in the following sense: for every input $t \in \tmonadn n \mati k \rSigma$, and every port $i \in \set{1,\ldots,\arity t}$, the same value is obtained by: (a) recursive flattening $t$ and then composing all of the twists that are found on the path from the root to port $i$; (b) applying $\ranked{g_n}$ and then computing the twist corresponding to port $i$. 
    
    For the induction base $n=1$, hereditarily homogeneous inputs are units, and there are finitely many of them and the function can be derived on a case by case basis. 
    
    Consider the induction step, where the lemma has already been proved for $n$ and we want to prove it for $n+1$. The function is the composition
    \begin{align*}
        \ranked{
            \xymatrix@C=2cm{
                \tmonadn {n+1} \mati k \Sigma \ar[r]^{\tmonad g_n} & \tmonad \mati k{(\tmonad \Sigma)} \ar[r]^{\text{Lemma~\ref{lem:homo-twist}}}&  \mati k  {(\tmonad \tmonad \rSigma)} \ar[r]^{\mati k \flatt} & \mati k \rSigma
            }
        }
    \end{align*}
    Consider a  hereditarily homogeneous input $t   \in \ranked{\tmonadn{n+1} \mati k \Sigma}$. 
    \begin{enumerate}
            \item Apply the function from the induction assumption to every label of $t$, i.e.~apply 
        \begin{align*}
        \ranked{
            \xymatrix{
                \tmonadn {n+1} \mati k \Sigma \ar[r]^{\tmonad g_n} & \tmonad \mati k{(\tmonad \Sigma)}
            }
        }
        \end{align*}
        \item Let $t_1$ be the output from the previous step. Because $\ranked {g_n}$ is consistent with twists, and $t$ is hereditarily homogeneous, it follows that $t_1$  is either a shallow term, or it is homogeneous with respect to the twist homomorphism.  If $t_1$ is a shallow term, then we apply the shallow unfolding operation from .. . Otherwise, we $t_1$ is homogeneous
        , because $t$ is hereditarily homogeneous and $\ranked{g_n}$ is consistent with twists. Therefore, we can apply the function
        from Lemma~\ref{lem:homo-twist}, with the alphabet being $\tmonad \rSigma$. 
        \item The result of the previous step is a term $t_2 \in \mati k {(\tmonad \tmonad \rSigma)}$. To this term, we apply $\mati k \flatt$, yielding the final result.
    \end{enumerate}
    A routine check shows that the function $\ranked{g_{n+1}}$ defined above satisfies the property in the statement of the lemma, and that it is furthermore consistent with the twist homomorphism.     
\end{proof}