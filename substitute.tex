\section{STTs with one unary register}
\label{sec:one-register}

% \begin{definition}
%     Let $\Sigma$ be a ranked set. We can view $\trees \Sigma$ as a multisorted algebra as follows.
%     \begin{itemize}
%         \item the sorts are arities;
%         \item the elements of arity $n$ are $n$-ary terms in $\Sigma$;
%         \item for every ranked set $X$ and every $t \in \trees (\Sigma+X)$ there is an operation
%         \begin{align*}
%             (\trees \Sigma)^X \to \trees \Sigma
%         \end{align*}
%     \end{itemize}
% \end{definition}
% Define $\aalg_\Sigma$ to be the multisorted algebra where:


\begin{lemma}\label{lem:one-register}
    Let $f$ be recognised by a first-order definable streaming tree transducer, which has one register that is unary. Then $f$ is first-order tree function.
\end{lemma}

Let us fix in the rest of this section an SST $S$ with input and output alphabets $\Sigma$ and $\Gamma$, a set of states $Q$, a unique register $r$ which is unary and a transition function $\delta_a$ for every $a\in \Sigma$. Let $U$ be the set of register updates used by $S$, that is:
$$U=\{u\ \mid\  \exists \vec{q}, q' \in Q, a\in \Sigma, \delta_a(q)=(q',u)\}$$
Since $S$ has only one register,  $U$ can be seen as a finite subset of  $\trees_1( \Gamma + k.r)$, where $k$ is the maximal arity of $\Sigma$.
In words, $U$ is a finite set of unary trees over $\Gamma$ and $k$ copies of $r$.

Let $\mathcal{U}=(U,ar)$ be the ranked set whose underlying set is $U$ and the arity of each symbol is the number of copies of $r$ it uses. 

Here are examples of ranked symbols of $\mathcal{U}$, where we denote by $r_i$ the $i^{th}$ copy of $r$:
\begin{center}
Picture
\end{center}

Be aware of the distinction between the arity of a symbol of $\mathcal{U}$, which is the number of copies of $r$, and the arity of its underlying tree which is always 1. To make this distinction clear, we will denote by $\underline{u}$ the tree of arity 1 underlying the ranked symbol $u$ of $\mathcal{U}$. 

We define in the following the substitution function, which replaces inductively every copy of the register $r$ by its value.
\begin{definition}
Let $\norm{\_}:\trees_0(\Uu)\to \trees_1(\Gamma)$ be the function defined inductively as follows:

If $T=u[T_1,\dots,T_n]$, where $u\in\Uu$, then $\norm{T}=\underline{u}[\norm{T_1}/r_1,\dots,\norm{T_n}/r_n]$. 

%Note that $\norm{\_}$ is not arity-preserving.

\noindent Let $\bullet$ be a nullary symbol not in $\Gamma$. We set: 
\begin{align*}
  Subst \colon\trees_0(\Uu) &\to \trees_0(\Gamma+\bullet)\\
  T &\mapsto \norm{T}[\bullet].
\end{align*} 
\end{definition}

\begin{example}
\begin{center}
A tree $T$ of $\trees \Uu$ $\qquad\qquad\mapsto\qquad\qquad$ Its substitution $Subst(T)$ 
\end{center}
\end{example}

Let us show that $Subst$ is a first-order tree function. We will show that the computation of the subsitution function can be made in several atomic steps, each of them defining a first-order tree function.
 
\medskip
\noindent\textbf{Step 1:} We have noticed that the tree underlying a symbol of $\Uu$ is of arity $1$. To bridge this mismatch beteen the arity of a symbol and its underlying tree, we apply the following
rank-preverving function, where $@$ is a binary symbol and $\bullet$ the nullary symbol used in the definition of the function $Subst$:
 \begin{align*}
  Match\colon \Uu &\to \trees(\Gamma+\bullet+k@)\\
  u &\mapsto \underline{u}[\bullet][@/r].
\end{align*} 
In words, the function $Match$ transforms the occurrences of the unary symbol $r$ appearing in $u$ into the binary symbol $@$, and closes the free variable of $\underline{u}$ by the nullary symbol $\bullet$.
\begin{center}
Picture
\end{center}
\medskip
\textbf{Step 2:} After step 1, each symbol of $\Uu$ became a tree of $\trees(\Gamma+\bullet+n.@)$ of the same arity. Inside each such tree, we isolate the block of nodes which are the ancestors of $\bullet$. This function is of type $\trees(\Gamma+k.@+\bullet)\to \trees (\trees (\Gamma+k.@+\bullet)+\Gamma+k.@)$. We call \emph{skeleton} the block isolated by this function, ad we denote by 
$SK$ the type $\trees (\Gamma+k.@+\bullet)$.
\begin{center}
Picture
\end{center}
The composition of Step 1 and Step 2 functions yields the function $Skel:\Uu\to \trees (SK+\Gamma+k.@)$. 
\begin{center}
Picture
\end{center}
Since $Skel$ is rank preserving and has a finite domain, it is then a fo tree function. We can then lift it to the trees of $\trees \Uu$ via the combinator $\trees$. Here is an example of what we get after these steps.
\begin{center}
Picture
\end{center}
 \medskip
\textbf{Step 3:} We apply a flattening to get a tree of type $\trees(SK+\Gamma+k.@)$. 
\begin{center}
Picture
\end{center}
\medskip
\textbf{Step 4:} We apply the block function to isolate the sketeons and the $@$'s from the other symbols. We get a tree of type $\trees (\trees(SK+k.@)+\trees\Gamma)$. As usual when whe decompose a tree into blocks, we should tell whot should we do for each kind of these blocks. on the block of type $\trees \Gamma$, we apply the identity. We describe in step 5 what we should do the $\trees(SK+@)$ blocks.

\medskip
\noindent \textbf{Step 5:} Pour les arbres de type $\trees (SK+@)$, on commence par flat les skeleton, pour avoir un arbre de type $\trees(\Gamma+\bullet+@)$ (Pour ce faire il suffit de transformer les symboles $@$ en $\trees @$, ensuite on injecte $SK$ et $\trees @$ dans $\trees(\Gamma+\bullet+@)$, puis on flatten).
On applique ensuite un parcours en profondeur de l'arbre ainsi obtenu.
 

