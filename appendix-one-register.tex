\section{Evaluation of $\lambda$-terms}
\label{sec:eval}

\subsection{A naive presentation of $\lambda$-terms}

\subsection{$\lambda$ terms with a bound set of (sub)-types}

\begin{definition}[Simple types]
Let $B$ be a set of basic types. Simple types are generated by the following syntax: 
\begin{align*}
\tau:= \ o\ |\  \tau\rightarrow \tau \qquad o\in B
\end{align*}
\end{definition}

\begin{definition}
Let $S$ be a finite set of simple types, $V=\{x_1^{\sigma_1},x_2^{\sigma_2},\dots\}$ be a finite set of typed variables, whose types come from $S$ (ie. $\sigma_i \in S$) and let  $\Sigma$ be a finite ranked set. 
We define the ranked set $\ranked{\mathcal{A}_{S,V,\Sigma}}$ as follows:
 $$\ranked{\mathcal{A}_{S,V,\Sigma}}:=$$
We set $\ranked{\Lambda_{S,V,\Sigma}}:=\tmonad(\ranked{\mathcal{A}_{S,V,\Sigma}})$. 
\end{definition}
 \newcommand{\rlambda}{\ranked{\Lambda}}
 \newcommand{\rlambdalin}{\ranked{\Lambda^{\sf{lin}}}}
An element of $\ranked{\Lambda_{S,V,\Sigma}}$ is said to be a well-formed $\lambda$-term (or simply a $\lambda$-term) if the type of the $i^{th}$ output of each node matches the type of the input of its $it^{th}$ sibling (if it exists).

The notion of free and bound variables for $\lambda$-terms are as usual. The operation of $\beta$-reduction is standard, and can be described by the following shema:

Note that $\beta$ reduction is not a function from $\ranked{\Lambda_{S,V,\Sigma}}$ to $\ranked{\Lambda_{S,V,\Sigma}}$ as ports may be duplicated. 

We denote by $\ranked{\Lambda^{\sf{lin}}_{S,V,\Sigma}}$ the set of linear $\lambda$-terms, that is elements of $\ranked{\Lambda_{S,V,\Sigma}}$ such that every occurrence of $\lambda x^\sigma$ binds exactly one occurrence of $x^\sigma$. Note that $\beta$ reduction is an arity preserving function from $\ranked{\Lambda^{\sf{lin}}_{S,V,\Sigma}}$ to $\ranked{\Lambda^{\sf{lin}}_{S,V,\Sigma}}$.  

For linear $\lambda$-terms, $\beta$ reduction is terminating since the size of the term desreases stricty by 3 (corresponding to the nodes $\text{@}, \lambda x^\sigma$ and $x^\sigma$ of the eliminated redex) at each reduction. As $\beta$-reduction is confluent, we can talk then about the normal form of a linear $\lambda$-term.

On definit $\beta_{\sf{left}}$ comme la fonction qui reduit le redex le plus a gauche. (une maniere simple de parler de la $\beta$ reduction, qui est une relation, comme une fonction).

La fonction $\beta_{\sf{left}}$ est clairement une fo tree-to-tree function.  
Dans le calcul de la forme normal, il y a une sorte d'iteration et ce n'est pas immediat que cette fonction soit fo aussi. Nous allons montrer que c'est le cas. 


If $S, V$ and $\Sigma$ are clear from the context, we omit them in the subscript of $\ranked{\Lambda_{S,V,\Sigma}}$ and $\ranked{\Lambda^{\sf{lin}}_{S,V,\Sigma}}$ and we write simply $\rlambda$ and $\rlambdalin$. We fix in the rest of this section a finite set of types $S$, a finite set of typed variables $V$ and a finite  ranked set $\Sigma$.
 

\begin{theorem}
There is an fo tree-to-tree functions ${\sf{Eval}}:\rlambda \to\rlambda$ such that its restriction to $\rlambdalin$ computes the normal form.
\end{theorem}

The proof proceeds by induction on the set of types $S$. The main remark is that if the evaluation of a redex of type $\sigma$ creates new redexes, then those one have a type stricty smaller than $\sigma$, as illustarated by the following figure.

So if we are able to show that the function that evaluates all the redexes of a given type 

\begin{theorem}
There is an fo tree-to-tree function ${\sf{Eval}_{x^\sigma,\tau}}:\rlambda \to\rlambda$ such that its restriction to $\rlambdalin$ evaluates the redexes of type $\tau$ and of variable $x^\sigma$.
\end{theorem}

The first step is to 