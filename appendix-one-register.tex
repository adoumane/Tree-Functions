\section{Evaluation of $\lambda$-terms}
\label{sec:eval}

\newcommand{\NonLinTerms}[2]{\Lambda_{#1} #2}
 \newcommand{\rlambda}{\ranked{\Lambda}}
 \newcommand{\rlambdalin}{\ranked{\Lambda^{\sf{lin}}}}
 \newcommand{\rlambdathin}{\ranked{\Lambda^{\sf{thin}}}}
\newcommand{\pictureline}[2]{\\   \begin{minipage}{0,6\textwidth}
    #1 
\end{minipage} & \begin{minipage}{0,4\textwidth}#2\end{minipage} \\}



\begin{lemma}
For every simple type $\tau$ in $S$, there is a first-order query $\varphi_\tau$ such that:
$$ \forall M\in \NonLinTerms S X \qquad M,u \models \varphi_\tau \Longleftrightarrow M|_u:\tau$$
where $M|_u$ is the subterm of $M$ rooted in $u$. 
\end{lemma}

\begin{proof}
Let us show that checking whether the type of a $\lambda$-term is $\tau$ is a first-order query. For that, notice that the type of a term depends only on its left-most branch. In fact, the type of a term is exactly the type of its left-most branch in the following sens.

Consider the (unranked) alphabet $ X_\lambda:= X\cup \{\text{@}, \lambda x | x\in X\}$. We can equip the words over $X_\lambda$ with the following typing rules:
$$\frac{}{x: \sigma} \qquad \frac{u:\tau}{u\lambda x: \sigma\rightarrow \tau} \qquad \frac{u:\sigma\rightarrow\tau}{u\text{@}:\tau}\qquad\text{(where $x$ is of type $\sigma$)}$$
We say that $w$ is of type $\tau$ and write $w:\tau$ if there is a typing derivation for $w:\tau$.

We can associate to every branch of a $\lambda$-term a word over $X_\lambda$ corresponding to the sequence of its labels read bottom-up. By induction on $\lambda$-terms, we can easily show that the type of a $\lambda$-term is the type of the word corresponding to its leftmost branch. 

By this last observation, we can reduce the query asking if the type of a term is $\tau$, to the same query but on $X_\lambda$ words. To show that the former is a first-order query, it is then sufficient to show that the following word language 
\begin{align*}
W_\tau = \{w\in X.\{\text{@}, \lambda x | x\in X\}^*\ |\ w:\tau \} 
\end{align*}
is first-order definable, or equivalently that  $W_\tau$ is recognized by a counter-free NFA. For that we proceed as follows: first, we show that $W_\tau$ is recognized by a pushdown automaton $A_\tau$. Then we will show that the its stack height is bounded, thus $A_\tau$ can be turned into a non-deterministic finite automaton $N_\tau$. Finally, we show that the obtained automaton $N_\tau$ is actually counter-free.  

For a formal definition of pushdown automata (PDA) and (counter-free) non-deterministic finite automata (NFA) see~\ref{}.

Consider the following PDA $A_\tau$ whose
\begin{itemize}
\item set of states $Q$ is $\{i, p, q\}$, where $q$ is accepting;
\item input alphabet is $X_\lambda$;
\item stack alphabet is $S$, with initial stack alphabet $\bot$;
\item and whose transition function is described by the following figure:
\begin{center}

\begin{tikzpicture}[->, % makes the edges directed
%stealth’, % makes the arrow heads bold
node distance=5cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10, inner sep=1pt,minimum size=0pt}, % sets the properties for each ’state’ node
initial text=$ $,]
\node[state, initial] (q1) {$ i$};
\node[state,  right of=q1] (q2) {$ p$};
\node[state, accepting,right of=q2] (q3) {$ q$};
\draw 
(q1) edge[above] node{$
 x, \perp\mapsto \sf{push}(\sigma_n),\dots,\sf{push}(\sigma_1)$} (q2)
(q1) edge[below] node{$
 \text{if } x: \sigma_1\rightarrow\dots\rightarrow\sigma_n$} (q2)
(q2) edge[loop above] node{ $\begin{array}{cccc}
\lambda y, \_ &\mapsto& \sf{push}(\sigma) &   \text{if } y:\sigma\\
\text{@}, \gamma\in S &\mapsto &\sf{pop}&
\end{array}$} (q2)
(q2) edge[above] node{$
\epsilon, \tau \mapsto \sf{pop}
$} (q3);
\end{tikzpicture}
\end{center}
\end{itemize}
A word $w$ is accepted by $A_\tau$ if there is a run that reaches the end of $w$ in the accepting state $q$ with an empty stack. We write $(r, s)\xrightarrow{w} (r', s')$ if there is a run over the word $w$ which starts in the state $r\in Q$ and with a stack $s$ and ends up in the state $r'$ and with a stack $s'$.


By induction on the lenght of the word $w$, we can easily show that:
\begin{lemma}
For every word $w\in X.\{\text{@},\lambda x | x\in X \}^*$, we have that:
 $$(i, \perp)\xrightarrow{w} (p, \sigma_n\dots\sigma_1) \qquad\text{iff} \qquad 
w:\sigma_1\rightarrow\dots\rightarrow\sigma_n$$ 
\end{lemma}

Using this lemma, we can easily show that $A_\tau$ recognizes $W_\tau$. Another direct consequence of Lemma~\ref{} is that the stack height of $A_\tau$ is bounded, since the set $S$ used to type the words is finite. Thus $A_\tau$ can be turned into an NFA, by encoding the stack information in the states. More precisely, the states of $N_\tau$ are pairs $(r,s)$ where $r\in Q$ and $s$ is a stack of height at most $m$, the initial state is $(i,\perp)$ and there is a transition $(r,s)\xrightarrow{a}(r',s')$ where $a\in X_\lambda\cup\{\epsilon\}$ if there is a corresponding run in $A_\tau$. Let us show that $N_\tau$ is counter free. 

Let us start with some observations. In the automaton $A_\tau$, the effect of a word $w$ on a stack $s$, starting from the state $p$ is the following: it erases the first $n$ top level elements of $s$, and replaces them by a word $u$. The number $n$ does not depend on the stack $s$, nor on the word $u$ but only on $w$. This is exactly what the following lemma claims.

\begin{lemma}
For every word $w$ over ${X_\lambda}^*$, there is a natural number $n$ and a word $u\in S^*$ such that if $(p,s)\xrightarrow{w}(p,s')$ then $s$ and $s'$ can be decomposed as follows:
$$s=t.v,\qquad s'=t.u\qquad \text{ and }\qquad |v|=n.$$
\end{lemma}
The proof is an easy induction on the lenght of $w$. As a consequence we have that:
\begin{itemize}
\item If $(p,s_1)\xrightarrow{w}(p,s_2)\xrightarrow{w}(p,s_3)$ and $|s_2|>|s_1|$ then $|s_3|>|s_2|$.
\item If $(p,s_1)\xrightarrow{w}(p,s_2)\xrightarrow{w}(p,s_3)$ and $|s_2|<|s_1|$ then $|s_3|<|s_2|$.
\item If $(p,s_1)\xrightarrow{w}(p,s_2)\xrightarrow{w}(p,s_3)$ and $|s_2|=|s_1|$ then $s_3 =s_2$.
\end{itemize}

Let us show that $N_\tau$ is counter-free. Suppose by contradiction that there is a word $w$ and stacks $s_1,\dots, s_n$ such that 
$(p,s_1)\xrightarrow{w}(p,s_2)\xrightarrow{w}\dots(p,s_n)\xrightarrow{w}(p,s_1)$. By the first two properties above, we have necessarily that $|s_1|=\dots=|s_n|$. Thus by the third property, we have that $s_1=\dots=s_n$
\end{proof}



 The operation of $\beta$-reduction is standard: it is the smallest congruence on terms (with no restriction on the use of variables) over $\mathcal{A}$ containing the following relation:
 \begin{center}
 Picture 3
 \end{center}
Note that the application of a $\beta$-reduction to a $\lambda$-term may result in a term which is not in $\rlambda$ since ports may be duplicated. If applied to a linear $\lambda$-terms, $\beta$-reduction produces a linear $\lambda$-term having the same arity. 
\begin{center}
Picture 4
\end{center}

\medskip
For linear $\lambda$-terms, $\beta$ reduction is terminating since the size of the term desreases stricty by 3 (corresponding to the nodes $\text{@}, \lambda x^\sigma$ and $x^\sigma$ of the eliminated redex) after each reduction. As $\beta$-reduction is confluent, we can talk then about the normal form of a linear $\lambda$-term.

\medskip
We set $\beta_{\sf{left}}$ to be the function that reduces the outermost and leftmost redex of a linear $\lambda$-term (this is an easy way to transform the relation $\beta$ into a function). The function $\beta_{\sf{left}}$  is clearly an fo tree-to-tree function. However, computing the normal form requires an iteration of $\beta_{\sf{left}}$ which is a typical non fo operation. Despite this, we will show that the evaluation of linear $\lambda$-terms is an fo tree-to-tree function. More precisely:


\begin{theorem}
There is an fo tree-to-tree functions ${\sf{Eval}}:\rlambda \to\rlambda$ such that its restriction to $\rlambdalin$ computes the normal form.
\end{theorem}

The proof proceeds by induction on the set of types $S$. The main observation is that if the evaluation of a redex of type $\sigma\rightarrow \tau$ creates a new redex, then the type of the latter is $\sigma$, in particular it is in $S\setminus\{\sigma\rightarrow\tau\}$. Thus, we only need to show that the function that evaluates all the redexes of a fixed type $\sigma\rightarrow\tau$ is an fo tree-to-tree function.  To show the last point, and since we have only finitely many typed variables, it is enough to show that the function that evaluates all the redexes of a fixed type $\sigma\rightarrow\tau$ and a fixed variable $x^\sigma$ is an fo tree-to-tree function (we call such redexes $x^\sigma$-redexes of type $\sigma\rightarrow\tau$). This will be the goal of the rest of this section. 

\begin{theorem}\label{thm:evalOneType}
There is an fo tree-to-tree function ${\sf{Eval}_{x^\sigma,\sigma\rightarrow\tau}}:\rlambda \to\rlambda$ whose restriction to $\rlambdalin$ evaluates the  $x^\sigma$-redexes of type $\sigma\rightarrow\tau$.
\end{theorem}

We fix in the rest of this section the types $\sigma$ and $\tau$ and the typed variable $x^\sigma$.

\subsection{Evaluation of thin $\lambda$-terms}

We start by showing that the evaluation of a restricted class of linear $\lambda$-terms, which we call thin, is an fo tree-to-tree function.   

\begin{definition}[Thin $\lambda$-terms]
A thin $\lambda$-terms is a term from $\rlambdalin$ in which a node is branching (ie a node having at least two sons which are not ports) if and only if it is a $\text{@}$ node, whose left son is a $\lambda x^\sigma$ node. We denote by $\rlambdathin$ the set of thin $\lambda$-terms.
\end{definition}

Since thin $\lambda$-terms branch only on redexes, the result of their evaluation is a word (that is, a term where every node has at most one son).  We will show that this word can actually be obtained by a pre-order traversal of the original $\lambda$-term. 
Since pre-order traversal is a basic fo tree-to-tree function, we can conclude that evaluation of thin $\lambda$-terms is a tree-to-tree function as well. 

\begin{center}
Picture 5
\end{center}

\begin{proposition}\label{prop:EvaluateThin}
There is an fo tree-to-tree function ${\sf{Eval}^{\sf{thin}}_{x^\sigma,\sigma\rightarrow\tau}}:\rlambda\to\rlambda$, whose restriction to $\rlambdathin$ evaluates the $x^\sigma$-redexes of type $\sigma\rightarrow\tau$.
\end{proposition}

\begin{proof}
Let $t$ be a thin $\lambda$-term and let $u$ be its normal form. As noticed before, $u$ has the shape of a word. Moreover, since $t$ is linear, the nodes of $u$ are exactly the nodes of $t$ which are not $x^\sigma$-redexes of type $\sigma\rightarrow\tau$, nor the nodes $x^\sigma$ they bind (ie. there is a label-preserving bijection $f$ between theses two sets of nodes).
We show that:
\noindent \begin{enumerate}
\item The order in which the inner nodes (ie. non ports) of $u$ appear is the tree order of $t$.
\item Let $n$ be a node of $u$ and $m$ be its corresponding node in $t$. The port $x$ of $u$ is the $i^{th}$ son of $n$ if and only if it the port $x$ of $t$ is the $i^{th}$ port of $m$.  
\end{enumerate} 

To establish the second claim, it is enough to show it for one step of $\beta$-reduction. But this last point is clear by a simple analysis of $\beta$-reduction, as far as we consider that the right son of the $\text{@}$ node of every redex is not a port. This is is guaranteed by the definition of thin $\lambda$-terms. 

To establish the first claim, let us consider two inner nodes $n, m$ of $t$ which are also nodes of $u$, and such that $n$ is smaller than $m$ is the tree order of $t$. We show that $n$ is a descendent of $m$ in $u$. There is two cases to consider:

\textbf{Case 1.} Either $n$ is a descendent of $m$ in $t$, in which case we can conclude easily since $\beta$-reduction preserves the descendent relation. Indeed, by a small analysis of $\beta$-reduction, one can notice that a reduction step may extend the descendent relation, but can never change (or break) the order of two comparable nodes in the original $\lambda$-term.    

\textbf{Case 2.} Otherwise, let us consider the lowest common ancestor $p$ of $m$ and $n$. We proceed by induction on the lenght of the path between $m$ and $p$. Notice first that since the only branching nodes of a thin term are $x^\sigma$-redexes, then $p$ is necessarily an $\text{@}$ node, whose left son $q$ is a $\lambda x^\sigma$ node. 
Notice first that $m$ is smaller than the free variable $r$ bound by $q$ w.r.t. the tree order. Indeed, if this was not the case, the free variable $r$ would not be bound by the node $q$, as illustrated by the following figure.
\begin{center}
Picture 6
\end{center}
We are then left with the following two situations:
\begin{center}
Picture 7
\end{center}    

Using these ingredients, let us construct now an fo tree-to-tree transduction which evaluates the $x^\sigma$-redexes of type $\sigma\rightarrow\tau$.
\begin{center}
Picture 8
\end{center}


    \begin{tabular}{ll}
    \pictureline
    {We start by tagging all the redexes of $t$ and their bound variables by $r$. This is an fo rational function, thus it can be performed by a derivable function. The result as a term in $\tmonad (\ranked{\mathcal{A}}+\ranked{\mathcal{A}^r})$, $\ranked{\mathcal{A}^r}$ being a copy of $\ranked{\mathcal{A}}$ where each element is tagged by $r$. Note that the nodes of $u$, the normal form of $t$, are the non-tagged node.}
    { \text{picture a}}
 \pictureline
    {We apply the pre-order traversal function. We get a term in $\tmonad \ranked{\Gamma}$ where $\ranked{\Gamma}:=\ranked{\mathcal{A}}+\ranked{\mathcal{A}^r}+\bullet+\bullet+\bullet$.}
    { \text{picture b}}
 \pictureline
    {Now we need to eliminate the tagged nodes. For that we start by adding the unary symbol $\#$ as a right son of each $\bullet$ node, getting a term in $\tmonad(\ranked{\Gamma+\#})$. This function is clearly derivable. }
    { \text{picture c}}
 \pictureline
    {We apply $\sf{block}^\uparrow$ to separate the symbol $\#$ from the others. We obtain a term in $\ranked{\tmonad(\tmonad \Gamma+\tmonad\#)}$}
    { \text{picture d}}
\pictureline
    {To each kind of blocks,  ($\ranked{\tmonad \Gamma}$ or $\ranked{\tmonad \#}$) we apply the functions $f: \ranked{\tmonad{\Gamma}} \to \ranked{\tmonad(\tmonad \Gamma+\tmonad\#)}$ and $g: \ranked{\tmonad{\#}} \to \ranked{\tmonad(\tmonad \Gamma+\tmonad\#)}$ which are both the identity function, except for the following elements:
    $$
    f(\bullet[\text{@}[\bullet,\bullet],p_1])=f(\bullet[\lambda x^\sigma\bullet],p_1])=f(\bullet[x^\sigma,p_1])=\bullet[p_1]$$
    
    For every n-ary element of $\ranked{\mathcal{A}}$, we have that:
 $$\begin{array}{c}
  f(\bullet[a[p_{i_1},\dots,p_{i_k}, \bullet, p_{i_{k+1}},\dots, p_{i_{n-1}}],p_{i_n}])\\
  =a[p_{i_1},\dots,p_{i_k}, p_{i_n}, p_{i_{k+1}},\dots, p_{i_{n-1}}]\\
f(\bullet[a[p_1,\dots,p_n]])=a[p_1,\dots,p_n]\\
g(\#[p_1])=p_1
\end{array}$$
After that, we apply a flattening, to get a term in $\ranked{\tmonad(\Gamma+\#)}$.
}
{ \text{picture e}}
\pictureline
{We have got the desired term, but not with the desired type. To obtain a term in $\ranked{\tmonad{\mathcal{A}}}$, we transform each tagged element of $\ranked{\mathcal{A}^r}$ into its untagged version, transform $\bullet_2$ into $\text{@}$, and $\bullet_0$ into $x^\sigma$. Finally, we erase the symbols $\#$ and $\bullet_1$.}{}
    \end{tabular}

 
\end{proof}

\subsection{$\beta$-reduction commutes with factorization} The second ingredient to show Thm.~\ref{thm:evalOneType} is to notice  that factorizing a term (in the sens of Def.~\ref{}), applying some $\beta$-reduction steps to the factors, then flattening, can be simulated by appliying  $\beta$-reduction steps directly to the original $\lambda$-term.

Let us state this property more formally. For that, we can generalise the lifting of functions to the lifting of relations as follows. 
Let $\Sigma$ be a ranked set. If $R\subseteq \ranked{\Sigma}\times\ranked{\Sigma}$ is an arity preseving relation (that is $\arity{u}=\arity{v}$ whenever $(u,v)\in R$), then $R$ can be lifted to $\tmonad R\subseteq \ranked{\tmonad \Sigma} \times \ranked{\tmonad \Sigma}$ in a natural way. 

Since $\beta$-reduction is an arity preserving relation  over linear $\lambda$-terms, its reflexive transitive closure $\beta^*$ is arity preserving as well.  We can lift then the later to $\tmonad \beta^*\subseteq \rlambdalin\times\rlambdalin$.
The following proposition is a direct consequence from the fact that $\beta$ is a congruence on terms.
  
\begin{proposition}\label{prop:betaCommutesWithFacto}
For every foctorization $f:\rlambda \to \tmonad \rlambda$, the following diagram commutes:
\begin{align*}
        \xymatrix{
     \rlambdalin \ar[d]_{\beta^*}\ar[r]^f& \tmonad \rlambdalin \ar[d]^{\tmonad\beta^*} \\
           \rlambdalin  &\ar[l]_{\sf{flat}} \tmonad \rlambdalin
        }
        \end{align*}
\end{proposition}



\subsection{Factorizing $\lambda$-terms into blocks of thin $\lambda$-terms}

\begin{definition}[Full redex]
Let $t$ be a linear $\lambda$-term. A full-redex is a set of nodes  containing an $x^\sigma$-redex of type $\sigma\rightarrow\tau$, the node $x^\sigma$ it binds, together with the set of nodes between the binder of the redex and its bound variable.  
\end{definition}
\begin{center}
Picture 9
\end{center}


\begin{proposition}\label{prop:FactoIntoThin}
There is an fo tree-to-tree factorisation $f:\rlambda \to \tmonad\rlambda$ such that for every $t\in\rlambdalin$
\begin{itemize}
\item any full redex of $t$ is entirely contained in one of the factors of $f(t)$;
\item the factors of $f(t)$ are thin $\lambda$-terms.
\end{itemize}
\end{proposition}

\begin{proof}
Let us constract an fo derivable factorization satisfying the two conditions of the statement.  

 \begin{tabular}{ll}
    \pictureline{We start by tagging all the redexes and their bound variables by $r$. The result as a term in $\tmonad (\ranked{\mathcal{A}}+\ranked{\mathcal{A}^r})$, $\ranked{\mathcal{A}^r}$ being a copy of $\ranked{\mathcal{A}}$ where each element is tagged by $r$. We set $\ranked{\mathcal{A}'}:= \ranked{\mathcal{A}+\mathcal{A}^r}$}{}
    \pictureline{We add the unary symbol $\#$ as a parent of each tagged symbol $\lambda x^\sigma$, then we apply a $\sf{block}^\uparrow:\ranked{\tmonad(\mathcal{A}'+\#)}\to \ranked{\tmonad(\tmonad(\mathcal{A}')+\tmonad\#})$. Doing so, each block $\ranked{\tmonad(\mathcal{A}')}$ contains at most one tagged binder $\lambda x^\sigma$ and the (tagged) variable $x^\sigma$ it binds.}{}
	\pictureline{To each block $\ranked{\tmonad(\mathcal{A}')}$, we apply the fo-rational function $f:\ranked{\tmonad{\mathcal{A}'}}\to \ranked{\tmonad(\mathcal{A}'_++\mathcal{A}'_-)}$, which adds $+$ to the nodes having as descendent a tagged node $x^\sigma$, and adds $-$ to the others.  }{}
   \pictureline{To each block $\ranked{\tmonad(\mathcal{A}'_++\mathcal{A}'_-)}$, we apply $\sf{block}^\uparrow: \ranked{\tmonad(\mathcal{A}'_++\mathcal{A}'_-)}\to \ranked{\tmonad(\tmonad(\mathcal{A}'_+)+\tmonad(\mathcal{A}'_-))}$. By linearity, each $\ranked{\tmonad(\mathcal{A}'_+)}$ block is a thin $\lambda$-term containing the path from a binder to its free variable.
    }{}
    \pictureline{Now, we erase the blocks $\ranked{\tmonad{\#}}$ and apply flat. We get a term in $\ranked{\tmonad(\tmonad(\mathcal{A}'_+)+\tmonad(\mathcal{A}'_-))}$.}{}
    \pictureline{We apply $\sf{block}^\uparrow:  \ranked{\tmonad(\tmonad(\mathcal{A}'_+)+\tmonad(\mathcal{A}'_-))}\to \ranked{\tmonad(\tmonad\tmonad(\mathcal{A}'_+)+\tmonad\tmonad(\mathcal{A}'_-))}$, then flat each block $\ranked{\tmonad\tmonad(\mathcal{A}'_+)}$ and $\ranked{\tmonad\tmonad(\mathcal{A}'_-)}$. We obtain a term in $\ranked{\tmonad(\tmonad(\mathcal{A}'_+)+\mathcal{A}'_-)}$, where each block $\ranked{\tmonad(\mathcal{A}'_+)}$ is a thin $\lambda$-term. Moreover, every redex is contained in a $\ranked{\tmonad(\mathcal{A}'_+)}$ block, except for the redexes whose binders are the roots of the  $\ranked{\tmonad(\mathcal{A}'_+)}$ blocks. To conclude, one only needs to add the $\text{@}$ above each such binder to its correponding block. }{}
    \pictureline{For that, we add the unary symbol $\#$ as a right son of each tagged $\text{@}$ symbol of $\mathcal{A}'_-$. We obtain a term in $\ranked{\tmonad(\tmonad(\mathcal{A}'_+)+\mathcal{A}'_-+\#)}$. Then we apply $\sf{block}^\uparrow:\ranked{\tmonad(\tmonad(\mathcal{A}'_+)+\mathcal{A}'_-+\#)}\to \ranked{\tmonad(\tmonad(\tmonad(\mathcal{A}'_+)+\mathcal{A}'_-)+\tmonad{\#})}$}{}
    \pictureline{We eliminate the blocks $\ranked{\tmonad{\#}}$ and apply flat, thus getting a term in $\ranked{\tmonad(\tmonad(\mathcal{A}'_+)+\mathcal{A}'_-)}$. We reapply block to seperate the blocks $\ranked{\tmonad(\mathcal{A}'_-})$ from the others, apply some flatening and eliminate all the taggs ($r$, +, -), in orther to get a term in $\ranked{\tmonad(\tmonad(\mathcal{A}))}$.}{}
    
    
   \end{tabular}
   
\end{proof}

\subsection{Gathering all the pieces.}
Theorem~\ref{thm:evalOneType} follows easily from Propositions~\ref{prop:EvaluateThin},\ref{prop:betaCommutesWithFacto} and \ref{prop:FactoIntoThin}.

\begin{proof}[Proof of Theorem.~\ref{thm:evalOneType}]
Let us show that the evaluation of all  $x^\sigma$-redexes of type $\sigma\rightarrow\tau$ is derivable. We start by applying to our $\lambda$-term the factorisation $f$ from Prop.~\ref{prop:FactoIntoThin}. As the factors are thin $\lambda$-terms, we can evaluate them by lifting the function from Prop.~\ref{prop:EvaluateThin}. We apply a flat to obtain again a $\lambda$-term. The later is a $\beta^*$-redex of the original $\lambda$-term by Prop.~\ref{prop:betaCommutesWithFacto}. Moreover, since every full-redex of the original $\lambda$-term was in one of the factors, all the $x^\sigma$-redexes has been reduced, which concludes the proof. 
\end{proof}