
\section{Functions computed by register transducers are derivable}
\label{sec:stt-derivable}
In the previous section, we showed how to derive the first computation phase in a register transducer, namely the first-order relabelling.  In this section, we deal with the second phase, namely evaluating register updates. We will show that evaluating the  register updates is a derivable function,  as stated in the following lemma.
\begin{lemma}\label{lem:derive-register-updates}
    For every first-order register transducer, the  following tree-to-tree function  is derivable:
    \begin{eqnarray*}
    \trees{\ranked{\text{(register updates)}}} &\to & \trees \rGamma \\
    t & \mapsto & \text{contents of the output register}\\
    && \text{after evaluating $t$}
    \end{eqnarray*}    
\end{lemma}

Combining the above lemma with Lemma~\ref{lem:schlingloff} from the previous section, we conclude that all first-order register transducers are derivable:
\begin{proposition}
    \label{prop:many-register} 
Every first-order  tree transducer computes a derivable function. 
\end{proposition}
In turn, combining the above proposition with  Theorem~\ref{thm:stt}, which says that every first-order tree-to-tree transduction can be computed by a first-order register transducers,  completes the proof of the more difficult top-down implication in our main theorem, Theorem~\ref{thm:main}.  

The rest of this section, as well as the next section, are devoted to proving Lemma~\ref{lem:derive-register-updates}
Fix a register transducer, with register names $\regnames$ and output alphabet $\rGamma$.   From now on, when speaking about register updates or register valuations, we assume these register names and this alphabet. 

\paragraph*{The $\lambda$-representation of terms.} 
To describe the register updates in a transducer, we will use notions from $\lambda$-calculus.  
We assume that the reader is familiar with the basic notions of the simply typed $\lambda$-calculus; more detailed definitions can be found in~\cite{sorensen_lectures_2006}; we will also give more precise definitions in Section~\ref{sec:one-register}.
% Define a \emph{$\lambda$-term} to be an expression built using the following grammar
% \begin{align*}
%  \underbrace{x,y,z,\ldots}_{\text{variables}} \quad \underbrace{MN}_{\text{application}} \quad \underbrace{\lambda x.M}_{\text{$\lambda$-abstraction}}.
% \end{align*}
% We use simply typed $\lambda$-calculus. This means that every variable is associated to a type, and we only consider terms which are well-typed. The types that we use are simple types: these 
% Sometimes, we extend the syntax, by allowing a symbols from the output alphabet  $\rGamma$:  terms of the form $a(M_1,\ldots,M_n)$, where $a \in \rGamma$ is a symbol of arity $n$. 
For an $n$-ary term $ t \in \tmonad \rGamma$, define its \emph{$\lambda$-representation} to be the $\lambda$-term obtained by  replacing the  $i$-th port  of $t$ with a variable $x_i$, for every $i \in \set{1,\ldots,n}$, and then  binding all the  variables $x_1,\ldots,x_n$  at the beginning of the term, as explained in the following picture:
\mypic{105}
The $\lambda$-representation uses every variable exactly once -- such $\lambda$-terms are called \emph{linear} -- which will play a role later on.
% \begin{enumerate}
%     \item Every variable is used exactly once. Such $\lambda$-terms are sometimes called \emph{linear}.
%     \item Assume a simple type system with an atomic type $\otype$ and one binary arrow type constructor:
%     \begin{align*}
%     \tau := \underbrace{\otype}_{\substack{\text{atomic}\\ \text{type}}} | \underbrace{\tau \to \tau}_{\text{functions}}.
%     \end{align*}
%     In this paper, one can think of the atomic type $\otype$ as describing trees. Then all of the variables in the $\lambda$-representation have the atomic type $\otype$. This will no longer be true later in this section, where register updates will be represented by $\lambda$-terms. 
% \end{enumerate}
The  $\lambda$-representation can be formalised as a tree, over the ranked alphabet:
\begin{align*}
\ranked{ \Gamma_\lambda \quad \eqdef \quad \Gamma + \set{\black{\overbrace{x_1,x_2,\ldots}^\text{arity 0},\overbrace{\lambda x_1,\lambda x_2,\ldots}^\text{arity 1}, \overbrace{@}^{\text{arity 2}}}}}.
\end{align*}
The binary application symbol @ has  not been used so far, but it will be used later on for representing register updates.
When the outputs are viewed as trees, the function
\begin{align}\label{eq:lambda-representation-term}
\xymatrix@C=2cm{
    \tmonad \rSigma 
    \ar[r]^{\text{$\lambda$-representation}} &
    \trees {\ranked{\Gamma_\lambda}}
}
\end{align}
is not arity-preserving, since all outputs have arity zero. For tree inputs, $\lambda$-representation is the identity function. 
\amitodo{I do not see the point of defining the lambda representation of term. Need for a smooth transition?}

\paragraph*{The $\lambda$-representation of register updates.} To represent register updates using $\lambda$-terms, we use  the matrix power. Unlike for terms,    $\lambda$-representation of register updates is an  arity preserving function, of type
\begin{align}\label{eq:lambda-representation-regup}
\ranked{
    \xymatrix@C=2cm{
 \text{register updates}    \ar[r]^-{\text{$\lambda$-representation}} &
 \mati k {(\tmonad\Gamma_\lambda)}
}
},
\end{align}
where $k$ is the number of registers. This function is illustrated in Figure~\ref{fig:labmda-representation-for-register-updates}. 
\miktodo{Give a definition, maybe?}
We will not claim that this function is derivable in general; but it will be derivable if we restrict the domain to a finite set of register updates, by virtue of having a finite domain.



\begin{figure}[]
    \centering
\mypic{107}    
    \caption{$\lambda$-representation for register updates. In this example, there are three registers $r,s,t$ of arities 2,1,0, respectively. The register update is binary, i.e.~it inputs two register valuations.}
    \label{fig:labmda-representation-for-register-updates}
\end{figure}

It is worth pointing out that if $u$ is a register update, then $u$ is monotone (in the sense Definition~\ref{def:stt}) if and only if its $\lambda$-representation is monotone (in the sense of matrix power as defined in  Section~\ref{sec:prime-and-combinators}). 


\paragraph*{Putting it all together.}
Having defined the $\lambda$-representation for terms and register updates, we now observe  that the semantics of a register automaton are translated -- under $\lambda$-representation -- to unfolding the matrix power and evaluating a $\lambda$-term (by evaluating a $\lambda$-term, we mean computing its normal form).  This observation is stated in Figure~\ref{fig:labmda-representation-for-register-updates} and the following lemma.

\begin{figure}
    \captionsetup{singlelinecheck=false}
    \centering
    \xymatrix@C=3cm{
        \trees \ranked{\text{(register updates)}} 
        \ar[dd]_{\substack{\text{evaluate}\\\text{register}\\\text{updates}}}^{\text{(a)}}
        \ar[r]^-{\trees(\text{\ranked{$\lambda$-representation}})}_{\text{(c)}}
        &
        \trees \ranked{(\mati k{(\tmonad \Gamma_\lambda)})}
        \ar[d]^{\substack{\text{unfold}\\\text{matrix}\\\text{power}}}_{\text{(d)}} \\
        & 
        (\trees \ranked{\Gamma_\lambda})^k 
        \ar[d]^{\substack{\text{evaluate}\\\text{$\lambda$-terms}}}_{\text{(e)}}\\
         \text{register valuations}
        \ar[r]_-{\text{$\lambda$-representation}}^{\text{(b)}}
        &
        (\trees \ranked{\Gamma_\lambda})^k
    }    
    \caption[foo bar]{In the diagram, the arrows describe the following operations:
    \begin{enumerate}
        \item[(a)] is as defined in the semantics of register transducers; 
        \item[(b)] 
        is $\lambda$-representation of terms as defined in~\eqref{eq:lambda-representation-term}; 
        \item[(c)]  is $\lambda$-representation of register updates as defined in~\eqref{eq:lambda-representation-regup};
        \item[(d)] is the unfolding as described in Section~\ref{sec:prime-and-combinators}; 
        \item[(e)] is computing the $\beta$-normal form for each $\lambda$-term.
    \end{enumerate}
       }
    \label{fig:register-lambda}
\end{figure}

\begin{lemma}
    The diagram in Figure~\ref{fig:labmda-representation-for-register-updates} commutes.
\end{lemma}

The lemma follows  directly from the definitions, and is given without proof. When talking about evaluation of $\lambda$-terms, as in arrow (e) of the diagram, we mean computing the $\beta$-normal form, i.e.~substituting arguments for their corresponding variables until such substitution is no longer possible. The evaluation of $\lambda$-terms is  discussed in more detail in the next section. 

% For the output register in the transducer,  the $\lambda$-representation is the same thing as the output tree, since $\lambda$-representation is the identity for trees (i.e.~terms of arity zero). It follows that the output tree in a register transducer is obtained by following arrows (a) and (b) in the diagram from Figure~\ref{fig:labmda-representation-for-register-updates}, and then projecting onto the coordinate which corresponds to the output tree. 



We claim that all of the arrows (c), (d) and (e) on the  right-down path  in the diagram from Figure~\ref{fig:labmda-representation-for-register-updates}   are derivable:
\begin{itemize}
    \item[(c)] Since we are working with a fixed register transducer, there is a finite set of register updates that it uses, and we only need to compute the $\lambda$-representation for those updates. It follows that operation (a) in the figure, when restricted to the finite set of register updates used by the transducer, is derivable.
    \item[(d)] Arrow (d) represents the unfolding of the matrix power, which is one of the prime functions and therefore derivable. 
    \miktodo{Mention how the folds disappear}
%     More formally, the output type of the unfolding is an arity zero element of 
%     \begin{align*}
%     \ranked{
% \mati k {(\tmonad \rGamma_\lambda)} 
% \subseteq 
% \reduce k {\tmonad (\rGamma_\lambda \otimes \cdots \otimes \tmonad \rGamma_\lambda)}.
%     }
%     \end{align*}
%     To get rid of the spurious fold, we apply the prime function ..
    \item[(e)] Finally, arrow (e) represents the evaluation of $\lambda$-terms. In Section~\ref{sec:one-register}, we will  show that such evaluation is derivable, under certain assumption on the $\lambda$-terms which are satisfied by the $\lambda$-terms that appear in Figure~\ref{fig:labmda-representation-for-register-updates}.
\end{itemize}
Since arrows (c), (d), (e) are derivable, and the diagram commutes, it follows that  the composition of the arrows (a) and (b) is derivable. In other words, there is a derivable function which maps a tree of register updates to the $\lambda$-representation of the resulting register valuation. If we project the register valuation to the coordinate of the output register, we get the $\lambda$-representation of the output tree, which is the same thing as the output tree, since $\lambda$-representation does nothing for terms of arity zero. 

To finish the proof of Lemma~\ref{lem:derive-register-updates}, it remains to show that $\lambda$-terms can be evaluated using a derivable function.  This will be done in the next section. 





