
\section{Evaluation of register updates}
\label{sec:stt-derivable}
In this section, we deal with the second computation phase in a first-order register transducer, namely evaluating register updates. Together with Proposition~\ref{prop:forat} from the previous section, this completes the proof that all first-order register transducers are derivable. This in turn, together with Theorem~\ref{thm:stt} about expressive completeness of first-order register transducers, completes the proof of our main result. 


When showing derivability of  evaluation for register updates, we  use the language of $\lambda$-calculus.  In Section~\ref{sec:one-register},  we show that evaluation of $\lambda$-terms is derivable, under certain restrictions. This result is then used in Section~\ref{sec:updates-endgame}, where unfolding the matrix power is used to reduce the evaluation of register updates to the evaluation of $\lambda$-terms.  

\input{one-register}
%


% \paragraph*{Normalisation of non-pure terms.} Let $\rGamma$ be a finite ranked set. Trees over the alphabet $\rGamma+X^\lambda$ are called \emph{$\lambda$-terms over $\rGamma$} or simply \emph{non-pure} $\lambda$-terms.
% Th notions discussed earlier (free and bound variables, $\beta$-reduction and normalization) are the same for non-pure $\lambda$-terms. We suppose that all the element of $\rGamma$ are typed as follows:  the root together with the ports are all of type $\otype$, as illustrated below.
% \begin{center}
% \includegraphics[scale=.4]{pictures/type-gamma}
% \end{center}
% Of course, well-typedeness extends in a natural way. 

% We claim that under the same restrictions, Theorem~\ref{thm:normalise} holds for $\lambda$-terms over $\rGamma$. This follows from this (classical) encoding of the element of $\rGamma$ as pure $\lambda$-terms. 
% Every element  $a \in \rGamma$ of arity $n$ is represented, using  a variable $x_a$ of type 
% \begin{align}\label{eq:low-order-type}
% \overbrace{\otype \to \otype \to \cdots \to \otype}^{\text{$n$ times}} \to \otype
% \end{align}
% as a spine of application nodes of length $n$, ending with the variable $x_a$, as shown below.
% \begin{center}
% \includegraphics[scale=.4]{pictures/encode-gamma}
% \end{center}
% If a non-pure term satisfies the condition of Theorem~\ref{thm:normalise}, then so does its pure encoding. Indeed, the variables corresponding to $\rGamma$  -- which are not bound -- are the only ones used multiple times.  Furthermore, all sub-terms in the encoding have type of the form~\eqref{eq:low-order-type}, with $n$ being at most the maximal arity of letters in $\rGamma$. Summing up, the encoding of a non-pure $\lambda$-term is linear and can be typed using a bounded set of types, and therefore it falls under the scope of Theorem~\ref{thm:normalise}. 
  
\subsection{Evaluation of register updates}
\label{sec:updates-endgame}
In this section, we complete the proof of derivability for the evaluation of register updates. Fix a first-order register transducer, with registers names $\regnames$ and output alphabet $\rGamma$. From now on, when speaking about register updates or register valuations, we assume these register names and this alphabet. 
Our goal is to prove the following lemma. 
\begin{lemma}\label{lem:derive-register-updates}
    The  following tree-to-tree function  is derivable:
    \begin{itemize}
        \item {\bf Input.} $t \in \trees{\ranked{\text{(register updates)}}}$;
        \item {\bf Output.} Contents of  output register after evaluating $t$.
    \end{itemize}
    % \begin{eqnarray*}
    % \trees{\ranked{\text{(register updates)}}} &\to & \trees \rGamma \\
    % t & \mapsto & \text{contents of register 1 after evaluating $t$}\\
    % && \text{after evaluating $t$}
    % \end{eqnarray*}    
\end{lemma}As discussed at the beginning of  Section~\ref{sec:stt}, the lemma completes the proof  our main result, Theorem~\ref{thm:main}.  
To prove the lemma, we will model   register updates by evaluation of $\lambda$-terms as in Theorem~\ref{thm:normalise}. %This reduction will involve the matrix power. 

\paragraph*{Output letters in $\lambda$-terms.} We  use $\lambda$-terms to represent register contents, and therefore we add output letters to $\lambda$-terms. For the rest of Section~\ref{sec:updates-endgame}, we use an extended definition of $\lambda$-terms, which allows  constructing $\lambda$-terms
\begin{align}\label{eq:non-pure}
a(M_1,\ldots,M_n) \qquad \text{for every $a \in \rGamma$ of arity $n$.}
\end{align}
The typing rules are extended as follows: the arguments $M_1,\ldots,M_n$ need to have type $\otype$, and then the  type of~\eqref{eq:non-pure} is also $\otype$. As in the previous section, the $\lambda$-terms can be represented as trees, as in the following picture:
\mypic{118}
% We write $\ranked{\rGamma_\lambda}$ for the ranked alphabet used in the tree representation; this is the ranked alphabet from~\eqref{eq:alphabet-for-lambda-terms} plus the output alphabet $\rGamma$. 
Theorem~\ref{thm:normalise} works without change for the  $\lambda$-terms as discussed in this section. Note that here is no $\beta$-reduction rule for the symbols from the output alphabet. 


\paragraph*{$\lambda$-representations of register updates.} Let $k$ be the number of registers. Register valuations and register updates can be thought of as lists of terms, ordered using the linear order on registers. The main ingredient in the proof of Lemma~\ref{lem:derive-register-updates} is an arity preserving function, called \emph{$\lambda\text{-representation}$}, which represents register updates using the $k$-th matrix power of $\lambda$-terms. 

Let $X$ be a set of variables $\set{x_1\dots,x_m}$, where $m$ is the maximal arity among registers. All  variables have  type $\otype$.  Define  $\ranked{\Gamma_\lambda}$ to be $\rGamma$ plus the ranked alphabet defined in~\eqref{eq:non-pure} to represent $\lambda$-terms over $X$ as trees.  The     $\lambda$-representation of register updates is an  arity preserving function of type
\begin{align}\label{eq:lambda-representation-regup}
\ranked{
    \xymatrix@C=2cm{
 \text{register updates}    \ar[r]^-{\text{$\lambda$-representation}} &
 \mati k {(\tmonad\Gamma_\lambda)}
}
},
\end{align}
that we now define.  
Recall that a register update -- of arity say $n$ -- maps each register to a term over alphabet $\ranked{\Gamma + n\regnames}$. Let us use the name \emph{placeholders} for the elements of $\ranked{n \regnames}$ and write them as $r_i$ with $r \in \regnames$ and  $i \in \set{1,\ldots,n}$.
We begin by explaining the representation for  a term with  placeholders, which is a function
\begin{align}\label{eq:placeholders}
\xymatrix@C=2cm{
    \ranked{\tmonad(\rGamma+n R)} \ar[r]^{\text{$\lambda$-representation}} &
    \ranked{\tmonad {\Gamma_\lambda}}
}
\end{align}
that is explained in the following picture:
\mypic{103}
The function described above is not arity preserving: the arity of the output is the number of placeholders in the input, which need not be the same as the number of ports in the input. The correspondence of ports in the output term with placeholders in the input term is defined with respect to some arbitrary order on the placeholders, say the pre-order in which they appear in the input term. 

% We will represent it as a term over  define its $\lambda$-representation to be  of arity $l$, then $\lambda(t)$ is obtained by:
% \begin{enumerate}
% \item[(a)] Replacing the  $i$-th port  of $t$ with the variable $x_i$.
% \item[(b)] Binding all the  variables $x_1,\ldots,x_l$  at the beginning of the term, in this order.
% \item[(c)] Applying the following rewriting rule, where $r_i \in \ranked{nR}$
% \begin{align*}
% r_i(t_1,\dots,t_p) \mapsto @(@(\dots @(\portletter, t_1)\dots,t_{p-1}),t_p)
% \end{align*}
% which replaces every $p$-ary letter $r_i$ by a spine of $@$ of lenght $p$. In particular,when  $r_i$ is nullary, it is replaced by a port.
% This rewriting rules creates, for every name $r_i$, a new port. We call it the \emph{port of $r_i$}.
% \end{enumerate}
% This construction is is illustrated by the following picture.
% \begin{center}
% \includegraphics[scale=.33]{pictures/lambda}
% \end{center}

Having define the $\lambda$-representation of terms with place holders as in~\eqref{eq:placeholders}, we now define the $\lambda$-representation of register updates as in~\eqref{eq:lambda-representation-regup}. For a register update $(t_1,\ldots,t_k)$, where $t_i$ is the term with placeholders used in the $i$-th register,  its $\lambda$-representation is defined to be 
\begin{align*}
(\text{$\lambda$-representation of $t_1$},\ldots,\text{$\lambda$-representation of $t_k$})/f ,
\end{align*}
 where the grouping function $f$ is defined by
 \begin{align*}
 \text{port corresponding to  of $r_i$ } \mapsto (r,i).
 \end{align*}
Here is a picture
\mypic{119}

% The following example illustrates $\lambda$-representations in the case where we have two registers. To avoid the ambiguities, registers $1$ and $2$ are named $r$ and $s$ respectively in the figure.
% \begin{center}
% \includegraphics[scale=.33]{pictures/lambda-rep}

% \noindent {\small (a): port of $s_1$ contributes to the second position of the first port in the matrix power.}
% \end{center}
Here are important properties of the $\lambda$-representation for register updates defined above:
\begin{enumerate}
\item[(P1)] It is  arity preserving. If we restrict the domain to a finite set of register updates, then it is a prime function, by virtue of having finite domain.
\item[(P2)] If a register update is monotone  (in the sense Definition~\ref{def:stt})  then  its $\lambda$-representation is also monotone (in the sense of matrix power as defined in  Section~\ref{sec:unfolding}). The converse implication is also true. 
\item[(P3)] Every bound variable in the $\lambda$-representation is used exactly once, and the types that appear are of the form 
\begin{align*}
\overbrace{\otype \to \otype \to \cdots \to \otype \to \otype}^{\text{at most (maximal arity in $\rGamma$) times}} \to \otype,
\end{align*}
hence Theorem~\ref{thm:normalise} can be applied.
\end{enumerate}

 
%To get the feeling of this function, we will first present it in the case where the automaton has only one unary regiTheorem~\ref{thm:normalise}.ster. The general case will be presented  in a second step.
%
%\paragraph*{The case of one register (k=1).} There is mismatch between the arity of register updates and the arity of the terms they contain (which is always 1). This is illustrated by the left figure below: the register update is of arity 2, but its content is of arity 1. A consequence of this mismatch is that a term of register updates cannot be seen as a term of terms, and the prime function of flattening and block etc cannot be applied; in other words, the inner structure of register updates is not accessible.
%Let us fix a variable $x$ of type $o$. The $\lambda$-representation, described in the figure below, is intended to bridge this gap, while preserving the behavior of register updates. 
%\begin{center}
%\includegraphics[scale=.36]{pictures/lambda-rep}
%\end{center}
%In words, the $\lambda$-representation transforms the (unique) port of the inner term into $x$ and replaces every letter $r_i$ is by a redex, the pending port of this redex becomes \begin{figure}[]
    
%
%The $\lambda$-representation does not only match the arities between the register update and their content, it also  respects their behavior, as illustrated by the following diagram.
%\begin{center}
%\includegraphics[scale=.36]{pictures/lambda-rep-diagram}
%\end{center}
%In words, the evaluation of a term of register updates can be simulated, through  $\lambda$-representation, by unfolding and normalization functions, which are derivable. 
%
%\paragraph*{The general case.} Let us describe the $\lambda$-representation in the general case. As in the case $k=1$, the inner portes become the variable $x$, every register name becomes a redex. The issue here is how to combine the ports.
%
%\begin{center}
%\includegraphics[scale=.36]{pictures/lambda-rep-general}
%\end{center}
% To describe the register updates in a transducer, we will use notions from $\lambda$-calculus.  
% We will also give more precise description of the $\lambda$-calculus in Section~\ref{sec:one-register}; for the moment it is enough to assume that $\lambda$-terms are like trees, except that they allow variables $x,y,z,\ldots$; binding the variables using $\lambda x, \lambda y, \lambda z, \ldots$ and applying one term to another. The evaluation of $\lambda$-terms is performed by $\beta$-reduction
% \begin{align*}
% (\lambda x. M) N \qquad \to_\beta \qquad M[x:=N],
% \end{align*}
% which substitutes a variable by an argument. The $\lambda$-terms that we use are going to be simply typed, which will imply that $\beta$-reduction eventually terminates, arriving at a normal form (called the value of the $\lambda$-term), and this normal form will not depend on the order in which $\beta$-reduction was performed. 
% Define a \emph{$\lambda$-term} to be an expression built using the following grammar
% \begin{align*}
%  \underbrace{x,y,z,\ldots}_{\text{variables}} \quad \underbrace{MN}_{\text{application}} \quad \underbrace{\lambda x.M}_{\text{$\lambda$-abstraction}}.
% \end{align*}
% We use simply typed $\lambda$-calculus. This means that every variable is associated to a type, and we only consider terms which are well-typed. The types that we use are simple types: these 
% Sometimes, we extend the syntax, by allowing a symbols from the output alphabet  $\rGamma$:  terms of the form $a(M_1,\ldots,M_n)$, where $a \in \rGamma$ is a symbol of arity $n$. 

%The red circles in the above picture, which represent nodes of the input term, can be seen  as syntactic sugar: a node with a label  $a \in \rGamma$ of arity $n$ is represented  as a variable of type 
%\begin{align}\label{eq:low-order-type}
%\overbrace{\otype \to \otype \to \cdots \to \otype}^{\text{$n$ times}} \to \otype
%\end{align}
%applied to $n$ arguments. The variables corresponding to $\rGamma$  -- which are not bound -- are the only ones used multiple times; every other variable is used at most once in its scope.   Furthermore, all sub-terms in the $\lambda$-representation have type of the form~\eqref{eq:low-order-type}, with $n$ being at most the maximal arity of letters in $\rGamma$. Summing up, the $\lambda$-representation is affine and can be typed using a bounded set of types, and therefore it falls under the scope of Theorem~\ref{thm:normalise}.

%As discussed in Section~\ref{sec:one-register}, the $\lambda$-representation of a term in $\rGamma$ can be seen as a tree over a finite ranked alphabet; call this ranked alphabet $\ranked{\Gamma_\lambda}$. When the outputs are viewed as trees, the function
%\begin{align}\label{eq:lambda-representation-term}
%\xymatrix@C=2cm{
%    \tmonad \rSigma 
%    \ar[r]^{\text{$\lambda$-representation}} &
%    \trees {\ranked{\Gamma_\lambda}}
%}
%\end{align}
%is not arity-preserving, since all outputs have arity zero. For tree inputs, $\lambda$-representation is the identity function. 

%\paragraph*{The $\lambda$-representation of register updates.} To represent register updates using $\lambda$-terms, we use  the $k$-th matrix power, where  $k$ is the number of registers. The     $\lambda$-representation of register updates is an  arity preserving function, of type
%\begin{align}\label{eq:lambda-representation-regup}
%\ranked{
%    \xymatrix@C=2cm{
% \text{register updates}    \ar[r]^-{\text{$\lambda$-representation}} &
% \mati k {(\tmonad\Gamma_\lambda)}
%}
%}.
%\end{align}
%This function is illustrated in Figure~\ref{fig:labmda-representation-for-register-updates}. 
% \miktodo{Give a definition, maybe?}
%Although most likely this  function is not derivable in general;  it does become derivable if we restrict the domain to a finite set of register updates, by virtue of having a finite domain.





\label{page:monotone-discussed}


\paragraph*{Putting it all together.}
Having defined the $\lambda$-representation for terms and register updates, we now observe  that the semantics of a register automaton are translated -- under $\lambda$-representation -- to unfolding the matrix power and evaluating a $\lambda$-term.  This observation is illustrated in Figure~\ref{fig:register-lambda} and stated in the following lemma.
\begin{figure}[]
    \centering
\includegraphics[scale=.3]{pictures/lambda-rep-diagram}   
    \caption{Evaluation of register updates can be simulated, through $\lambda$-representation, by unfolding of matrix power followed by normalisation of $\lambda$-terms.}
    \label{fig:register-lambda}
    \amitodo{Maybe give the first line as an example in section 4, then give here only the second line? }
\end{figure}


\begin{lemma}\label{lem:commuting-endgame}
    The following diagram commutes 
        \captionsetup{singlelinecheck=false}
    \centering
    \xymatrix@C=3cm{
        \trees \ranked{\text{(register updates)}} 
        \ar[dd]_{\substack{\text{evaluate}\\\text{register}\\\text{updates}}}^{\text{(a)}}
        \ar[r]^-{\trees(\text{\ranked{$\lambda$-representation}})}_{\text{(c)}}
        &
        \trees \ranked{(\mati k{(\tmonad \Gamma_\lambda)})}
        \ar[d]^{\substack{\text{unfold}\\\text{matrix}\\\text{power}}}_{\text{(d)}} \\
        & 
        (\trees \ranked{\Gamma_\lambda})^k 
        \ar[d]^{\substack{\text{evaluate}\\\text{$\lambda$-terms}}}_{\text{(e)}}\\
         \text{register valuations}
        \ar[r]_-{\text{$\lambda$-representation}}^{\text{(b)}}
        &
        (\trees \ranked{\Gamma_\lambda})^k
    }    
%    \caption[foo bar]{In the diagram, the arrows describe the following operations:
%    \begin{enumerate}
%        \item[(a)] is as defined in the semantics of register transducers; 
%        \item[(b),(c)]   is $\lambda$-representation of register updates as defined in~\eqref{eq:lambda-representation-regup};
%        \item[(d)] is the unfolding as described in Section~\ref{sec:prime-and-combinators}; 
%        \item[(e)] is computing the $\beta$-normal form for each $\lambda$-term.
%    \end{enumerate}
%       }
\end{lemma}

The lemma follows  directly from the definitions, and is given without proof.  
We claim that all of the arrows (c), (d) and (e) on the  right-down path  in the diagram from Lemma~\ref{lem:commuting-endgame}  are derivable:
\begin{itemize}
    \item[(c)] Since we are working with a fixed register transducer, there is a finite set of register updates that it uses, and therefore  operation (a) in the figure is derivable by property (P1).
    \item[(d)] Arrow (d) represents the unfolding of the matrix power. By property (P2), the outputs of arrow (c) are monotone, and therefore we can use the monotone unfolding operation, which is a  prime function and therefore derivable. There is one technicality that needs to be explained about arrow (d). After applying (monotone) unfolding to the output of arrow (c), we get an  arity zero element of 
    \begin{align*}
        \ranked{
            \mati k {(\tmonad \rGamma_\lambda)}} = \reduce  k {\powersmall{(\tmonad \rGamma_\lambda)}{k}}.
    \end{align*}
    To convert this output into a tuple of trees, we use the last prime function in Figure~\ref{fig:monad} to remove the fold $\reduce k$.
    \item[(e)] Finally, arrow (e) represents the evaluation of $\lambda$-terms. This arrow is derivable thanks to Theorem~\ref{thm:normalise}. The assumptions of this theorem are met by property (P3).
\end{itemize}
Since arrows (c), (d), (e) are derivable, and the diagram commutes, it follows that  the composition of the arrows (a) and (b) is derivable. In other words, there is a derivable function which maps a tree of register updates to the $\lambda$-representation of the resulting register valuation. If we project the register valuation to the coordinate of the output register, we get the $\lambda$-representation of the output tree, which is the same thing as the output tree, since $\lambda$-representation does nothing for terms of arity zero. \footnote{@Mikolaj: this is true only when we dont see the nodes of lambda representations as a syntactic sugar. This is why I used this lambda terms over $\rGamma$ thing. }

This completes the proof of Lemma~\ref{lem:derive-register-updates}, and therefore also of the main theorem. 




