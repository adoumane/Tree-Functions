\section{Appendix on first-order relabelling}~\label{sec:AppendixForat}

\subsection{Proof of Lemma~\ref{lem:schlingloff}}

In this section, we provide more details about the proof of Lemma~\ref{lem:schlingloff}. We recall its statement below.

\begin{lemma} The first-order tree relabeling are equal to the smallest class of functions which is closed under composition and which  contains the following functions:
    \begin{enumerate}
        \item \label{it:relabeling} \emph{Relabeling}. To every finite $\rGamma,\rSigma$ and $\ranked {f : \rSigma \to \rGamma}$, the tree lifting $\trees \ranked f : \trees \rSigma \to \trees \rGamma$.
        \item \label{it:child} \emph{Child.} For every $\rSigma$ and  $i \in \set{1,2,\ldots}$, the characteristic function of the  unary query 
        \begin{align*}
            \underbrace{\child i (x).}_{\text{$x$ is an $i$-th child}}
        \end{align*}
         \item \label{it:until} \emph{Until.} For every finite $\rGamma, \rDelta \subseteq \rSigma$,  the characteristic function of the unary query
         \begin{align*}
              \underbrace{\exists y\ y > x \land \rDelta(y) \land  \forall z \ (x < z < y \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}} 
         \end{align*} 
         \item \label{it:since}\emph{Since.} For every $\rGamma, \rDelta \subseteq \rSigma$,    the characteristic function of the unary query
         \begin{align*}
              \underbrace{\exists y\ y < x \land \rDelta(y) \land  \forall z \ (y < z < x \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}}  
         \end{align*} 
    \end{enumerate}
    In items \ref{it:child} -- \ref{it:since}, the alphabet is $\rSigma$, so the characteristic functions have type $\trees \rSigma \to \trees(\rSigma + \rSigma)$. 
\end{lemma}
Clearly the functions in the lemma are first-order tree relabelings, and first-order tree relabelings are easily seen to be closed under composition, which gives the right-to-left inclusion in the lemma. The hard part is the left-to-right inclusion, which says that every first-order tree relabeling can be decomposed into functions as in items~\ref{it:relabeling} -- \ref{it:since}. 
The first  step in the proof of  the right-to-left inclusion is the observation that  every first-order tree relabeling can be decomposed as 
\begin{align*}
    g \circ f_1 \circ \cdots \circ f_n
\end{align*}
where $g$ is a relabeling as in item~\ref{it:relabeling} of the lemma and each $f_i$ is a  characteristic function of some unary query (not necessarily of the simple form indicated in items~\ref{it:child} -- \ref{it:since} in the lemma). This is a simple observation: the functions $f_1,\ldots,f_n$ annotate the tree with the truth values of the unary queries used in the definition of the  first-order relabeling, and $g$ uses these truth values to select the appropriate output label. The hard part of the lemma is showing that each $f_i$  can be further decomposed into functions as indicated in the lemma. This is where we us the result of Schlingloff~\cite[Theorem 2.6]{schlingloff1992expressive}, which says that all first-order definable tree properties can be defined using a temporal logic that has operators similar to the ones used in items~\ref{it:child} -- \ref{it:since} of the lemma. 

Schlingloff's result is about unorderd trees. In the following, we recall this result and show how to adapt it to our framework.
In order to show that first-order relabeling functions are derivable, we use a decomposition result, which says that first-order queries on trees over a ranked alphabet $\rGamma$ can be decomposed into the temporal operators of a logic that we call $2$-$\mathsf{CTL}$. 
This result can be seen as a direct consequence of \cite{}. But since the framework of this theorem is slightly different from ours, we recall it here, and show how our result can be derived from it.

Let $\rGamma$ be a ranked alphabet. The formulas of 2-$\mathsf{CTL}$ are generated by the following syntax:
\begin{align*}
\varphi, \psi:= \ a\in \rGamma \ | \ \odot_i \phi \ | \ \varphi\untilmod \psi \ | \ \varphi\sincemod\psi  
\end{align*}
The semantics of these formulas are defined for the ranked trees of $\trees \rGamma$ as follows.
\begin{enumerate}
\item A tree of $\trees \rGamma$ satisfies the formula $a\in\rGamma$ at the node $x$ if the label of $x$ is $a$.
\item $t, x\models \odot_i \varphi$ if the $i$-th child of $x$ satisfies $\varphi$.
\item  The formula $\varphi\untilmod \psi$  is valid  in the node $x$ if $x$ has a descendant $y$ with label in $\rDelta$, such that all nodes between $x$ and $y$ have label in $\rGamma$. 
\item $x$ has a descendant $y$ with label in $\rDelta$, such tha all nodes between $x$ and $y$ have label in $\rGamma$.
\end{enumerate}

\begin{lemma}%[Decomposition lemma]
For every first-ordre formula $\phi$, there is a $2$-$\mathsf{CTL}$ formula $T$ such that
$$ \forall t\in \trees \rGamma \qquad t,x\models \varphi \Leftrightarrow t,x\models T.$$
\end{lemma}

Shclingloff considers node labeled, branching bounded and   unordered (there is no order between the children of a node) trees. If $\Gamma$ is an (unranked) alphabet, we denote by $\trees_b\Gamma$ the set of unordered trees, labelled from $\Gamma$ and whose branching is at most $b$.   


The formulas of $4$-$\mathsf{CTL}$ are generated by the following syntax:
\begin{align*}
\varphi, \psi:= \ a\in \Gamma \ | \ \nextmod_i \phi \ | \ \varphi\untilmod \psi \ | \ \varphi\sincemod\psi  
\end{align*}
The semantics of $4$-$\mathsf{CTL}$ formulas is as before. The connective $\nextmod_i$ have the following semantics:
%
%\begin{theorem}\cite{}%[Decomposition lemma]
%For every first-ordre formula $\phi$, there is a $4$-$\mathsf{CTL}$ formula $T$ such that
%$$ \forall t\in \trees_b \Gamma \qquad t,x\models \varphi \Leftrightarrow t,x\models T.$$
%\end{theorem} 
% Let us explain how Lemma~\ref{} can be derived from Theorem~\ref{}. First Comment plonger les arbres de $\trees \rGamma$ dans le framework de Schlingloff. Soit $b$ l'arite maximale des elements de $\rGamma$. On denote par $\overline{\rGamma}$ le (unranked) set underlying $\rGamma$. 
%Il y a un plongement naturel 
%$$ \overline{\bullet}: \trees\rGamma \to \trees_b\Gamma$$

\paragraph*{Encoding our trees by Schlingloff's trees}
\paragraph*{Translating first-order formulas}
\begin{lemma} Let $\rGamma$ be a ranked set and $\phi$ be a first-order formula.
\begin{align*}
\forall t\in \trees \rGamma, \qquad t\models \phi \leftrightarrow t \models [\phi]
\end{align*} 
\end{lemma}

\paragraph*{From 4-CLT to 2-CTL}
 \begin{lemma} Let $\rGamma$ be a ranked set and $\phi$ be a first-order formula.
\begin{align*}
\forall t\in \trees \rGamma, \qquad t\models \overline{\phi} \leftrightarrow [t] \models \phi
\end{align*} 
\end{lemma}

\subsection{First-order relabelling are derivable}\label{sec:relabeling}

\begin{lemma}\label{lem:nextmod}
  For every finite $\rSigma$, $\rGamma\subseteq \rSigma$ and $i \in \set{1,2,\ldots}$, the characteristic function $\ranked{f:\tmonad \rSigma\to\tmonad(\rSigma+\rSigma)}$ of the  unary query 
        \begin{align*}
\text{``The }i\text{-th child of }x\text{ is in }\rGamma\text{''}
        \end{align*}
        is derivable.
\end{lemma}
\begin{proof}
To show that $\ranked{f}$ is derivable, we start applying the children function \begin{align*}
\ranked{\mathsf{Children}:\tmonad\rSigma\to \tmonad (\rSigma\otimes (\rSigma_0+0)^*)}
\end{align*} from Example~\ref{ex:sibling} which tags every nodes by the list of its children. Consider the function $g$
$$\begin{array}{rlll}
\ranked{g:}  \ranked{\rSigma\otimes (\rSigma_0+0)^*} &\ranked{\to}& \ranked{\Sigma +\Sigma}&\\
            \tensorpair{a,l}                           &
     \mapsto& \tensorpair{a,1}              &\text{if } l[i]\in\ranked{\rGamma_0}, \\
                    &   \mapsto& \tensorpair{a,2} &\text{otherwise.}   
\end{array}$$
which maps an element of $\rSigma$ tagged by a list to the first copy of $\rSigma$ if the $i$-th element of the list is in $\rGamma$ and to the second copy otherwise. The function $g$ is derivable since its domain is finite.
We finally get $\ranked{f}$ by lifting $\ranked{g}$ to terms.
\end{proof}

\medskip
\begin{lemma}\label{lem:untilmod}
For every finite $\rGamma, \rDelta \subseteq \rSigma$,  the characteristic function $\ranked{f:\tmonad\rSigma\to\tmonad(\rSigma+\rSigma)}$ of the unary query
         \begin{align*}
              \underbrace{\exists y\ y \geq x \land \rDelta(y) \land  \forall z \ (x < z < y \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes between $x$ and $y$ have label in $\rGamma$}}} 
              \end{align*}
is derivable.
\end{lemma}
\begin{proof}
We start by applying the factorization
\begin{align*}
\ranked{\ancfact : \tmonad \Sigma \to \tmonad(\tmonad(\Sigma\setminus(\Gamma\cup\Delta)) +\tmonad(\Gamma\cup\Delta))}
\end{align*}
which decomposes our terms into factors, depending on whether their node labels are in $\ranked{\Gamma\cup\Delta}$ or not. 
Note that the value of a node w.r.t. the until query depends only on the node labels of its factor. %(it is constant equal to $0$ in the case of $\Sigma\setminus(\Gamma\cup\Delta)$ blocks).

The nodes of the $\ranked{\tmonad(\rSigma\setminus(\rGamma\cup\rDelta))}$ factors do not satisfy the query, thus we will apply to them the function $\ranked{\tmonad g}$ obtained by lifting the function 
$$\begin{array}{rrll}
 \ranked{g:}& \ranked{\rSigma\setminus(\rGamma\cup\rDelta)}& \ranked{\to} &\ranked{\rSigma+\rSigma}\\
&a&\mapsto& \tensorpair{a,2}.
\end{array}$$
 
  
Nodes of the $\ranked{\tmonad(\Gamma\cup\Delta)}$  factors satisfy the query if and only if they have a descendant in  $\rDelta$.
Consider the function $\ranked{h}$ obtained by composing the descendant function $\ranked{\mathsf{Descendant}_\Delta}$ from Example~\ref{ex:descendant} with an injection $\ranked{\tmonad(\iota+\iota)}$
\begin{align*}
\underbrace{\ranked{\tmonad(\Gamma\cup\Delta) \xrightarrow{\ranked{\mathsf{Descendant}_\Delta}} \tmonad(\Gamma\cup\Delta+\Gamma\cup\Delta) \xrightarrow{\ranked{\tmonad(\iota+\iota)}}\tmonad(\Sigma+\Sigma)}}_{\ranked{h}}
\end{align*}
Finally, to get the characteristic function $\ranked{f}$, we apply $\ranked{\tmonad{g}}$ to the $\ranked{\tmonad(\Sigma\setminus(\Gamma\cup\Delta))}$ factors and $\ranked{h}$ to the other factors using the co-pairing combinator, then we flat the obtained term. 
\end{proof}


\begin{lemma}\label{lem:sincemod}
For every finite $\rGamma, \rDelta \subseteq \rSigma$,    the characteristic function of the unary query
         \begin{align*}
              \underbrace{\exists y\ y \leq x \land \rDelta(y) \land  \forall z \ (y < z < x \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}}  
         \end{align*} 
         is derivable.
\end{lemma}
\begin{proof}
The same proof as above, one only needs to replace the use of the function $\ranked{\mathsf{Descendant}_\Delta}$ by that of $\ranked{\mathsf{Ancestor}_\Delta}$, introduced in Example~\ref{ex:descendant}.
\end{proof}
