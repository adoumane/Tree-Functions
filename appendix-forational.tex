

\section{Appendix on first-order relabelling}~\label{sec:AppendixForat}

\subsection{From first-order queries to temporal logic}

In order to show that first-order relabelling are derivable, we use a decomposition result, which says that first-order queries on trees over a ranked alphabet $\rGamma$ can be decomposed into the temporal operators of a logic that we call $2$-$\mathsf{CTL}$. 
This result can be seen as a direct consequence of \cite{}. But since the framework of this theorem is slightly different from ours, we recall it here, and show how our result can be derived from it.

Let $\rGamma$ be a ranked alphabet. The formulas of 2-$\mathsf{CTL}$ are generated by the following syntax:
\begin{align*}
\varphi, \psi:= \ a\in \rGamma \ | \ \odot_i \phi \ | \ \varphi\untilmod \psi \ | \ \varphi\sincemod\psi  
\end{align*}
The semantics of these formulas are defined for the ranked trees of $\trees \rGamma$ as follows.
\begin{enumerate}
\item A tree of $\trees \rGamma$ satisfies the formula $a\in\rGamma$ at the node $x$ if the label of $x$ is $a$.
\item $t, x\models \odot_i \varphi$ if the $i$-th child of $x$ satisfies $\varphi$.
\item  The formula $\varphi\untilmod \psi$  is valid  in the node $x$ if $x$ has a descendant $y$ with label in $\rDelta$, such that all nodes between $x$ and $y$ have label in $\rGamma$. 
\item $x$ has a descendant $y$ with label in $\rDelta$, such tha all nodes between $x$ and $y$ have label in $\rGamma$.
\end{enumerate}

\begin{lemma}%[Decomposition lemma]
For every first-ordre formula $\phi$, there is a $2$-$\mathsf{CTL}$ formula $T$ such that
$$ \forall t\in \trees \rGamma \qquad t,x\models \varphi \Leftrightarrow t,x\models T.$$
\end{lemma}

Shclingloff considers node labelled, branching bounded and   unordered (there is no order between the children of a node) trees. If $\Gamma$ is an (unranked) alphabet, we denote by $\trees_b\Gamma$ the set of unordered trees, labelled from $\Gamma$ and whose branching is at most $b$.   


The formulas of $4$-$\mathsf{CTL}$ are generated by the following syntax:
\begin{align*}
\varphi, \psi:= \ a\in \Gamma \ | \ \nextmod_i \phi \ | \ \varphi\untilmod \psi \ | \ \varphi\sincemod\psi  
\end{align*}
The semantics of $4$-$\mathsf{CTL}$ formulas is as before. The connective $\nextmod_i$ have the following semantics:

\begin{theorem}\cite{}%[Decomposition lemma]
For every first-ordre formula $\phi$, there is a $4$-$\mathsf{CTL}$ formula $T$ such that
$$ \forall t\in \trees_b \Gamma \qquad t,x\models \varphi \Leftrightarrow t,x\models T.$$
\end{theorem} 
 Let us explain how Lemma~\ref{} can be derived from Theorem~\ref{}. First Comment plonger les arbres de $\trees \rGamma$ dans le framework de Schlingloff. Soit $b$ l'arite maximale des elements de $\rGamma$. On denote par $\overline{\rGamma}$ le (unranked) set underlying $\rGamma$. 
Il y a un plongement naturel 
$$ \overline{\bullet}: \trees\rGamma \to \trees_b\Gamma$$
 
\subsection{First-order relabelling are derivable}

\begin{lemma}\label{lem:nextmod}
  For every finite $\rSigma$, $\rGamma\subseteq \rSigma$ and $i \in \set{1,2,\ldots}$, the characteristic function $\ranked{f:\tmonad \rSigma\to\tmonad(\rSigma+\rSigma)}$ of the  unary query 
        \begin{align*}
\text{``The }i\text{-th child of }x\text{ is in }\rGamma\text{''}
        \end{align*}
        is derivable.
\end{lemma}
\begin{proof}
To show that $\ranked{f}$ is derivable, we start applying the sibling function $$\ranked{\mathsf{Sibling}:\tmonad\rSigma\to \tmonad (\rSigma\otimes (\rSigma+\bot)^*_0)}$$ from Example~\ref{ex:sibling} which taggs every nodes by the list of its children. Consider the function $g$
$$\begin{array}{rlll}
\ranked{g:}  \ranked{\rSigma\otimes (\rSigma+\bot)^*_0} &\ranked{\to}& \ranked{\Sigma +\Sigma}&\\
            \tensorpair{a,l}                           &
     \mapsto& \tensorpair{a,1}              &\text{if } l[i]\in\rGamma, \\
                    &   \mapsto& \tensorpair{a,2} &\text{otherwise.}   
\end{array}$$
which maps an element of $\rSigma$ tagged by a list to the first copy of $\rSigma$ if the $i$-th element of the list is in $\rGamma$ and to the second copy otherwise. The function $g$ is derivable since its domain is finite.

We finally get $\ranked{f}$ by lifting $\ranked{g}$ to terms of $\ranked{\tmonad(\rSigma\otimes (\rSigma+\bot)^*_0)}$.
\end{proof}

\medskip
\begin{lemma}\label{lem:untilmod}
For every finite $\rGamma, \rDelta \subseteq \rSigma$,  the characteristic function $\ranked{f:\tmonad\rSigma\to\tmonad(\rSigma+\rSigma)}$ of the unary query
         \begin{align*}
              \underbrace{\exists y\ y \geq x \land \rDelta(y) \land  \forall z \ (x < z < y \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes between $x$ and $y$ have label in $\rGamma$}}} 
              \end{align*}
is derivable.
\end{lemma}
\begin{proof}
We start by applying the factorisation
\begin{align*}
\ranked{\ancfact : \tmonad \Sigma \to \tmonad(\tmonad(\Sigma\setminus(\Gamma\cup\Delta)) +\tmonad(\Gamma\cup\Delta))}
\end{align*}
which decomposes our terms into factors, depending on whether their node labels are in $\ranked{\Gamma\cup\Delta}$ or not. 
Note that the value of a node w.r.t. the until query depends only on the node labels of its factor. %(it is constant equal to $0$ in the case of $\Sigma\setminus(\Gamma\cup\Delta)$ blocks).

The nodes of the $\ranked{\tmonad(\rSigma\setminus(\rGamma\cup\rDelta))}$ factors do not satisfy the query, thus we will apply to them the function $\ranked{\tmonad g}$ obtained by lifting the function 
$$\begin{array}{rrll}
 \ranked{g:}& \ranked{\rSigma\setminus(\rGamma\cup\rDelta)}& \ranked{\to} &\ranked{\rSigma+\rSigma}\\
&a&\mapsto& \tensorpair{a,2}.
\end{array}$$
 
  
Nodes of the $\ranked{\tmonad(\Gamma\cup\Delta)}$  factors satisfy the query if and only if they have a descendant in  $\rDelta$.
Consider the function $\ranked{h}$ obtained by composing the descendant function $\ranked{\mathsf{Descendant}_\Delta}$ from Example~\ref{ex:descendant} with an injection $\ranked{i}$
\begin{align*}
\underbrace{\ranked{\tmonad(\Gamma\cup\Delta) \xrightarrow{\ranked{\mathsf{Descendant}_\Delta}} \tmonad(\Gamma\cup\Delta+\Gamma\cup\Delta) \xrightarrow{\ranked{\mathsf{i}_\Delta}}\tmonad(\Sigma+\Sigma)}}_{\ranked{h}}
\end{align*}
The last injection $\ranked{i}$ is derived by co-pairing the basic injection $\ranked{\iota:\Gamma\cup\Delta\to \Sigma}$ with itself and lifting it to terms.

Finally, to get the characteristic function $\ranked{f}$, we apply $\ranked{\tmonad{g}}$ to the $\ranked{\tmonad(\Sigma\setminus(\Gamma\cup\Delta))}$ factors and $\ranked{h}$ to the other factors using the co-pairing combinator, then we flat the obtained term. 
\end{proof}


\begin{lemma}\label{lem:sincemod}
For every finite $\rGamma, \rDelta \subseteq \rSigma$,    the characteristic function of the unary query
         \begin{align*}
              \underbrace{\exists y\ y \leq x \land \rDelta(y) \land  \forall z \ (y < z < x \Rightarrow \rGamma(z)).}_{\substack{\text{$x$ has a descendant $y$ with label in $\rDelta$, such that}\\ \text{all nodes strictly between $x$ and $y$ have label in $\rGamma$}}}  
         \end{align*} 
         is derivable.
\end{lemma}
\begin{proof}
The same proof as above, one only needs to replace the use of the function $\ranked{\mathsf{Descendant}_\Delta}$ by that of $\ranked{\mathsf{Ancestor}_\Delta}$, introduced in Example~\ref{ex:descendant}.
\end{proof}
