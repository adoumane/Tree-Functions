
\section{First-order tree functions}
The goal of this paper is to describe the first-order tree-to-tree functions as the smallest class which contains certain atomic functions, and which is closed under applying certain combinators. To achieve this goal, we discuss functions that transform not just trees, but also \emph{terms}, which are trees with distinguished ports that can be substituted with trees (or other terms). One of the main points of using terms is that  they have a substitution structure, i.e.~one can build a terms of terms. 

\paragraph*{Types.} In the end we are interseted about tree-to-tree functions. However, to construct such functions, we will use intermediate operations which transform terms,  pairs of terms, or terms of terms, etc.
 The following definition describes the types that can be used by the intermediate operations.



\begin{definition}[Types]\label{def:types}
    Define a \emph{type} to be any ranked set which can be obtained from the atomic types by applying the type constructors, as described below.
    \begin{itemize}
        \item {\bf Atomic types.} 
           \begin{enumerate}
            \item every ranked set with finitely many elements;
            \item a ranked set, call it  $1$, which has one element on every arity;
        \end{enumerate}
    \item {\bf Type constructors.} 
     \begin{enumerate}
        \item {\bf Disjoint union $\Sigma+\Gamma$.} An element of $\Sigma+\Gamma$ is either an element of $\Sigma$ or an element of $\Gamma$, with the arities inherited from $\Sigma,\Gamma$. 
        \item {\bf Cartesian\footnote{This is the Cartesian product in the category where objects are ranked sets, and morphisms are arity preserving functions.}  product $\Sigma \times \Gamma$.} An  $n$-ary element of $\Sigma \times \Gamma$ is a pair of elements from $\Sigma, \Gamma$, respectively, whose arities are both $n$.
        \item {\bf Tensor product $\Sigma \otimes \Gamma$.} An  $n$-ary element of $\Sigma \times \Gamma$ is a pair of elements from $\Sigma, \Gamma$, respectively, whose arities  sum up to $n$.
        \item {\bf Terms.} For a ranked set  $\Sigma$, define a \emph{term}\footnote{The terms that we use are special kinds of terms, where each variable is used exactly once.} to be tree over the alphabet $\Sigma + \set \portletter$, where $\portletter$ is a fresh symbol of arity zero. Define $\trees \Sigma$ to be the ranked set of terms over $\Sigma$, where the arity of a term is the number of labels $\portletter$.
    \end{enumerate}  
    \end{itemize}
  
\end{definition}

\newcommand{\tensorpair}[2]{\langle #1, #2 \rangle}

The tensor constructor can be seen as a special case of the term constructor, since a tensor pair $\tensorpair a b$  can be viewed as a tree of depth two like in this picture:
\begin{center}
    (picture)
\end{center}
In fact, the term constructor can be viewed as a least fixpoint of tensor products, as expressed in the following isomorphism:
\begin{align*}
    \trees \Sigma \quad \simeq \quad  \set \portletter + \coprod_{a \in \Sigma} \underbrace{\trees \Sigma \otimes \cdots \otimes \trees \Sigma}_{\text{arity of $a$ times}}
\end{align*}


\paragraph*{Atomic functions.} Having described the types, we now describe the atomic functions that transform elements of these types.




\begin{definition}[Atomic functions]\label{def:atomic-functions} The \emph{atomic functions} are the following functions (for every types $\Sigma,\Gamma,\Sigma_0,\Sigma_1$): 
\begin{enumerate}
    \item The unique arity-preserving function $! : \Sigma \to 1$
    \item Every arity-preserving function when the domain $\Sigma$ is finite:
    \begin{align*}
        f : \Sigma \to \Gamma
    \end{align*}
    \item Projection and co-projection
    \begin{align*}
        \pi_i : \Sigma_0 \times \Sigma_1 \to \Sigma_i \qquad \iota_i : \Sigma_i \to \Sigma_0 + \Sigma_1
    \end{align*}
    \item Distribution of $+$ across $\times$:
\begin{align*}
    (\Sigma_0 + \Sigma_1 ) \times \Gamma \to (\Sigma_0 \times \Gamma) + (\Sigma_1 \times \Gamma)
\end{align*}
\item Assuming that $\Sigma$ is finite, the two canonical bijections (one in each direction) between the ranked sets:
 \begin{align*}
    \trees \Sigma \qquad \text{and} \qquad    \set \portletter + \coprod_{a \in \Sigma} \underbrace{\trees \Sigma \otimes \cdots \otimes \trees \Sigma}_{\text{arity of $a$ times}}
\end{align*}

\item Flattening
\begin{align*}
    \trees \trees \Sigma \to \trees \Sigma
\end{align*}

% \item Tree construction: for every $\sigma$ and every $a \in \sigma$  a function
% \begin{align*}
%     \underbrace{\trees \sigma \otimes \cdots \otimes \trees \sigma}_{\text{arity of $a$ times}} \to \trees \sigma
% \end{align*}

% \item Tree deconstruction: for every $\sigma$ and every $a \in \sigma$  a function
% \begin{align*}
%       \trees \sigma \to 1 + \underbrace{\trees \sigma \otimes \cdots \otimes \trees \sigma}_{\text{arity of $a$ times}}
% \end{align*}
\item Blocking
    \begin{align*}
        \trees (\Sigma + \Gamma) \to \trees (\trees \Sigma + \trees \Gamma)
    \end{align*}
    \item Comb
    \begin{align*}
        \trees 1 \to \trees 1
    \end{align*}
    \item Unfolding 
\begin{align*}
    \trees (\Sigma \otimes \Sigma) \to (\trees \Sigma) \otimes (\trees \Sigma)
\end{align*}
\item Some kind of port swapping
    
% \item The port-order function
% \begin{align*}
% \trees (\sigma + \tau) \to \trees (\sigma + \tau)
% \end{align*}

    % \item For every variables $x,y \in \varnames$ (mabye just $x=1$ and $y=2$) the function 
    % \begin{align*}
    %     swap : \trees \tau \to \trees \tau
    % \end{align*}
    
    % \item Some kind of swapping (maybe not needed)
    %     \item Let $\circ$ be a ranked set with one element of arity $\emptyset$.
    % \begin{align*}
    %     \trees(\sigma+\tau) \to \trees(\sigma+\tau+\circ) \otimes \trees(\sigma+\tau+\circ)
    % \end{align*}

\end{enumerate}
\end{definition}


The atomic functions can be combined into more complex functions using the following combinators.
\begin{definition}
     [Combinators] \label{def:combinators} \ 
    \begin{enumerate}
    \item Function composition
    \begin{align*}
    \frac{f : \Sigma \to \Gamma \quad g : \Gamma \to \Delta} {g \circ f : \Sigma \to \Delta}
\end{align*}

\item Lifting functions to trees
\begin{align*}
    \frac{f : \Sigma \to \Gamma} {\trees f : \trees \Sigma \to \trees \Gamma}
\end{align*}
\item Cases
\begin{align*}
    \frac{f_0 : \Sigma_0 \to \Gamma \quad f_1 : \Sigma_1 \to \Gamma} {[f_0,f_1] : \Sigma_0 + \Sigma_1 \to \Gamma}
\end{align*}

\item Pairing functions
\begin{align*}
    \frac{f_0 : \Sigma \to \Gamma_0 \quad f_1 : \Sigma \to \Gamma_1} {(f_0,f_1) : \Sigma \to \Gamma_0 \times \Gamma_1}
\end{align*}

\item Tensor product of functions
\begin{align*}
    \frac{f_0 : \Sigma_0 \to \Gamma_0 \quad f_1 : \Sigma_1 \to \Gamma_1} {\langle f_0,f_1 \rangle : \Sigma_0 \otimes \Sigma_1 \to \Gamma_0 \otimes \Gamma_1}
\end{align*}
\end{enumerate}
\end{definition}

We are now ready to define the first-order tree functions, which are the topic of this paper. 

\begin{definition}[First-order tree functions] \label{def:fo-tree-functions} \ 
    \begin{itemize}
        \item A \emph{first-order term functions} is any function that can be  generated from the atomic functions from Definition~\ref{def:atomic-functions} by applying the  combinators from Definition~\ref{def:combinators}.
        \item  A \emph{first-order tree function} is any first-order term function restricted to trees, i.e.~terms of arity zero.
    \end{itemize}    
\end{definition}


We are now ready to state the main result of this paper. 
\begin{theorem}\label{thm:main}
    The following classes of functions are equal\begin{itemize}
        \item First-order tree-to-tree transductions;
        \item First-order tree functions.
    \end{itemize}
\end{theorem}

The bottom-up inclusion, i.e.~the proof that every first-order tree function is a first-order tree-to-tree transduction, is proved by induction in Section~\ref{sec:to-transductions}.  The bottom-up inclusion is true by design, i.e.~the atomic functions and combinators were designed so that they could be easily  simulated using first-order transductions. 

The hard part of the theorem is showing that every first-order tree-to-tree transduction can be broken up, using the combinators, into the atomic functions. The proof strategy for the hard part is presented in Section~\ref{sec:strategy}, and is then realised in Sections~\ref{sec:fo-translation} and~\ref{sec:one-register}.