
\section{First-order tree functions}
The goal of this paper is to describe the first-order tree-to-tree functions as the smallest class which contains certain atomic functions, and which is closed under applying certain combinators. To achieve this goal, we discuss functions that transform not just trees, but also \emph{terms}, which are trees with distinguished ports that can be substituted with trees (or other terms). One of the main points of using terms is that  they have a substitution structure, i.e.~one can build a terms of terms. 

\paragraph*{Types.} In the end we are interseted about tree-to-tree functions. However, to construct such functions, we will use intermediate operations which transform terms,  pairs of terms, or terms of terms, etc.
 The following definition describes the types that can be used by the intermediate operations.



\begin{definition}[Types]\label{def:types}
    Define a \emph{type} to be any ranked set which can be obtained from the atomic types by applying the type constructors, as described below. We denote by $\Tt$ the set of all types. 
    \begin{itemize}
        \item {\bf Atomic types.} 
           \begin{enumerate}
            \item every ranked set with finitely many elements;
            \item a ranked set, call it  $1$, which has one element on every arity;
        \end{enumerate}
    \item {\bf Type constructors.} 
     \begin{enumerate}
        \item {\bf Disjoint union $\Sigma+\Gamma$.} An element of $\Sigma+\Gamma$ is either an element of $\Sigma$ or an element of $\Gamma$, with the arities inherited from $\Sigma,\Gamma$. 
        \item {\bf Cartesian\footnote{This is the Cartesian product in the category where objects are ranked sets, and morphisms are arity preserving functions.}  product $\Sigma \times \Gamma$.} An  $n$-ary element of $\Sigma \times \Gamma$ is a pair of elements from $\Sigma, \Gamma$, respectively, whose arities are both $n$.
        \item {\bf Tensor product $\Sigma \otimes \Gamma$.} An  $n$-ary element of $\Sigma \times \Gamma$ is a pair of elements from $\Sigma, \Gamma$, respectively, whose arities  sum up to $n$.
        \item {\bf Terms.} For a ranked set  $\Sigma$, define a \emph{term}\footnote{The terms that we use are special kinds of terms, where each variable is used exactly once.} to be tree over the alphabet $\Sigma + \set \portletter$, where $\portletter$ is a fresh symbol of arity zero. Define $\trees \Sigma$ to be the ranked set of terms over $\Sigma$, where the arity of a term is the number of labels $\portletter$.
    \end{enumerate}  
    \end{itemize}
  
\end{definition}

\newcommand{\tensorpair}[2]{\langle #1, #2 \rangle}

The tensor constructor can be seen as a special case of the term constructor, since a tensor pair $\tensorpair a b$  can be viewed as a tree of depth two like in this picture:
\begin{center}
    (picture)
\end{center}
In fact, the term constructor can be viewed as a least fixpoint of tensor products, as expressed in the following isomorphism:
\begin{align*}
    \trees \Sigma \quad \simeq \quad  \set \portletter + \coprod_{a \in \Sigma} \underbrace{\trees \Sigma \otimes \cdots \otimes \trees \Sigma}_{\text{arity of $a$ times}}
\end{align*}


\paragraph*{Atomic functions.} Having described the types, we now describe the atomic functions that transform elements of these types.




\begin{definition}[Atomic functions]\label{def:atomic-functions} The \emph{atomic functions} are the following functions (for every types $\Sigma,\Gamma,\Sigma_0,\Sigma_1$): 
\begin{enumerate}
    \item The unique arity-preserving function $! : \Sigma \to 1$
    \item Every arity-preserving function when the domain $\Sigma$ is finite:
    \begin{align*}
        f : \Sigma \to \Gamma
    \end{align*}
    \item Projection and co-projection:
    \begin{align*}
        \pi_i : \Sigma_0 \times \Sigma_1 \to \Sigma_i \qquad \iota_i : \Sigma_i \to \Sigma_0 + \Sigma_1
    \end{align*}
    \item Distribution of $+$ across $\times$:
\begin{align*}
    (\Sigma_0 + \Sigma_1 ) \times \Gamma \to (\Sigma_0 \times \Gamma) + (\Sigma_1 \times \Gamma)
\end{align*}
\item Distribution of $+$ across $\otimes$:
\begin{align*}
    (\Sigma_0 + \Sigma_1 ) \otimes \Gamma \to (\Sigma_0 \otimes \Gamma) + (\Sigma_1 \otimes \Gamma)
\end{align*}
\item Assuming that $\Sigma$ is finite, the two canonical bijections (one in each direction) between the ranked sets:
 \begin{align*}
    \trees \Sigma \qquad \text{and} \qquad    \set \portletter + \coprod_{a \in \Sigma} \underbrace{\trees \Sigma \otimes \cdots \otimes \trees \Sigma}_{\text{arity of $a$ times}}
\end{align*}
\item Flattening:
\begin{align*}
    \trees \trees \Sigma \to \trees \Sigma
\end{align*}
\item Blocking
    \begin{align*}
        \trees (\Sigma + \Gamma) \to \trees (\trees \Sigma + \trees \Gamma)
    \end{align*}
    \item Comb
    \begin{align*}
        \trees 1 \to \trees 1
    \end{align*}
    \item Unfolding: 
\begin{align*}
    \trees (\Sigma \otimes \Gamma) \to (\trees \Sigma) \otimes (\trees \Gamma)
\end{align*}
    \item Unit:
\begin{align*}
    \Sigma  \to \trees \Sigma
\end{align*}

\item Some kind of port swapping
\end{enumerate}
\end{definition}


The atomic functions can be combined into more complex functions using the following combinators.
\begin{definition}
     [Combinators] \label{def:combinators} \ 
    \begin{enumerate}
    \item Function composition:
    \begin{align*}
    \frac{f : \Sigma \to \Gamma \quad g : \Gamma \to \Delta} {g \circ f : \Sigma \to \Delta}
\end{align*}

\item Lifting functions to trees:
\begin{align*}
    \frac{f : \Sigma \to \Gamma} {\trees f : \trees \Sigma \to \trees \Gamma}
\end{align*}
\item Cases
\begin{align*}
    \frac{f_0 : \Sigma_0 \to \Gamma \quad f_1 : \Sigma_1 \to \Gamma} {[f_0,f_1] : \Sigma_0 + \Sigma_1 \to \Gamma}
\end{align*}

\item Pairing functions:
\begin{align*}
    \frac{f_0 : \Sigma \to \Gamma_0 \quad f_1 : \Sigma \to \Gamma_1} {(f_0,f_1) : \Sigma \to \Gamma_0 \times \Gamma_1}
\end{align*}

\item Tensor product of functions:
\begin{align*}
    \frac{f_0 : \Sigma_0 \to \Gamma_0 \quad f_1 : \Sigma_1 \to \Gamma_1} {\langle f_0,f_1 \rangle : \Sigma_0 \otimes \Sigma_1 \to \Gamma_0 \otimes \Gamma_1}
\end{align*}
\end{enumerate}
\end{definition}

We are now ready to define the first-order tree functions, which are the topic of this paper. 

\begin{definition}[First-order tree functions] \label{def:fo-tree-functions} \ 
    \begin{itemize}
        \item A \emph{first-order term functions} is any function that can be  generated from the atomic functions from Definition~\ref{def:atomic-functions} by applying the  combinators from Definition~\ref{def:combinators}.
        \item  A \emph{first-order tree function} is any first-order term function restricted to trees, i.e.~terms of arity zero.
    \end{itemize}    
\end{definition}
%\begin{remark}
Note that first-order term functions are arity preserving. 
%\end{remark}

To illustrate these first-order tree functions, we present a series of examples, many of which will be useful later.

\bigskip
\noindent \begin{example}[Identity] For every type $\Sigma$, the identity function $x\in\Sigma\mapsto x\in\Sigma$ is a first-order tree function. This is achieved by induction on the types: the identity function over a finite set of elements is first-order since its domain is finite, and the identity function over $1$ is the first-order function $!$. For $\Sigma$ and $\Gamma$ in $\Tt$ , the identity
function over $\Sigma+\Gamma$ is the disjoint union of the co-projections $\Sigma \to \Sigma + \Gamma$ and $\Gamma \to \Sigma + \Gamma$. The
identity function over $\Sigma \times \Gamma$ is the pairing of the projections $\Sigma \times \Gamma \to \Sigma$ and $\Sigma \times \Gamma \to \Gamma$. The
identity function over $\Sigma \otimes \Gamma$ is the tensor product of the identity over $\Sigma$ and the identity over $\Gamma$. Finally,
the identity function over $\trees\Sigma$ is constructed from the identity function over $\Sigma$ using the combinator $\trees$.
\end{example}

\bigskip
\noindent\begin{example}[If then else]  Let $g:\Sigma\to\Delta$ and $h:\Gamma\to\Delta$ be two first-order tree functions. Consider the the function:
 $$f:\trees(\Sigma+\Gamma)\to\trees\Delta$$
 which applies the function $g$ to the $\Sigma$ nodes of the input and the function $h$ to the $\Gamma$ ones. Let us show that this is a first-order tree function. First, we apply a block to get 
 a tree in $\trees(\trees\Sigma+\trees\Gamma)$. We lift both $g$ and $h$ using the combinator $\trees$ to get the functions $\trees g:\trees \Sigma\to\trees \Delta$ and $\trees h:\trees \Gamma\to\trees \Delta$, then we combine them using the case combinator. We lift the obtained function using the combinator $\trees$, we get then a function of type $\trees(\trees \Sigma+\trees\Gamma)\to\trees\trees\Delta$. Finally, the desired function $f$ is obtained by appliying a flattening. 
\end{example}


\bigskip
\noindent\begin{example}[Filter] Let $\Gamma, \Sigma\in\Tt$, where $\Sigma$ is a finite set of unary symbols. Consider the function:
$$ f:\trees (\Sigma+\Gamma)\to\trees \Sigma$$
which erases the elements of $\Gamma$ from the inupt tree. This function is well defined since erasing unary symbols does not not break the tree structure of the input. 
Let us explain why this is a first-order list function. 
Consider the function unit from $\Sigma$ to $\trees\Sigma$ and the constant function $\Gamma\to\trees\Sigma$ which associates to every element of $\Gamma$ the empty tree. The later is a first order tree function since its domain is finite. Using the if then else construction of Example~\ref{}, we get a tree in $\trees\trees\Sigma$. We conclude by applying a flattening. 
\end{example}

\bigskip
\noindent  \begin{example}[Root and leaves]
\begin{itemize}
\item The combinator which applies $f$ to the root and $g$ to the rest of the tree:
\begin{align*}
    \frac{f : \Sigma \to \Gamma_0 \quad g : \Sigma \to \Gamma_1}
     {\mathsf{root}_{f,g} : \trees\Sigma \to \trees(\Gamma_0 + \Gamma_1)}
\end{align*}
\item The combinator which applies $f$ to the leaves and $g$ to the rest of the tree:
\begin{align*}
    \frac{f : \Sigma \to \Gamma_0 \quad g : \Sigma \to \Gamma_1}
     {\mathsf{leaf}_{f,g} : \trees\Sigma \to \trees(\Gamma_0 + \Gamma_1)}
\end{align*}
\end{itemize}
\end{example}

\bigskip
\noindent\begin{example}[Descendent and ancestors]
\begin{itemize}
\item The function $\mathsf{Desc}_\Gamma: \trees \Sigma \to \trees (2\otimes\Sigma)$ which 
adds $1$ to the label of each node depending on whether it has a descendent in $\Gamma$.
\item The function $\mathsf{Anc}_\Gamma: \trees \Sigma \to \trees (2\otimes\Sigma)$ which 
adds $1$ to the label of each node depending on whether it has an ancestor in $\Gamma$.
\end{itemize}
\end{example}


\bigskip
\noindent\begin{example}[Depth-first traversal]
\end{example}

We are now ready to state the main result of this paper. 
\begin{theorem}\label{thm:main}
    The following classes of functions are equal\begin{itemize}
        \item First-order tree-to-tree transductions;
        \item First-order tree functions.
    \end{itemize}
\end{theorem}

The bottom-up inclusion, i.e.~the proof that every first-order tree function is a first-order tree-to-tree transduction, is proved by induction in Section~\ref{sec:to-transductions}.  The bottom-up inclusion is true by design, i.e.~the atomic functions and combinators were designed so that they could be easily  simulated using first-order transductions. 

The hard part of the theorem is showing that every first-order tree-to-tree transduction can be broken up, using the combinators, into the atomic functions. The proof strategy for the hard part is presented in Section~\ref{sec:strategy}, and is then realised in Sections~\ref{sec:fo-translation} and~\ref{sec:one-register}.