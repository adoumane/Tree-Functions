


\section{Streaming tree transducers}
\label{sec:stt}
The automaton model is based on streaming tree transducers~\cite{alur2017streaming}, although our syntax is based more on notions from universal algebra such as terms and substituion.
% We use an algebraic syntax for streaming tree transducers. 
% \emph{Linear polynomials.} Suppose that $\Sigma$ is a finite ranked alphabet.  For a ranked set $X$, define a \emph{polynomial with variables $X$ over $\Sigma$} to be any term in $\tmonad (\Sigma + X)$. Given such a polynomial $p$, and an arity preserving valuation $v : X \to \tmonad \Sigma$, we define $p(v)\in \tmonad \Sigma$ to be the term obtained from $p$ by replacing each variable with its value under $v$. The arity of $p(v)$ is the same as the arity of $p$.  A polynomial is called \emph{linear}, or non-duplicating, if each variable from $X$ is used at most once.

% \begin{definition}
%     For a ranked set $\Sigma$, define $\aalg_\Sigma$ to be the following multisorted algebra. 
%     \begin{itemize}
%         \item The sorts are arities, i.e.~numbers in $\set{0,1,2,\ldots}$, and elements of sort $n$ are $n$-ary terms in $\tmonad  \Sigma$;
%         \item The operations are the polynomial operations. 
%     \end{itemize}
% \end{definition}




\paragraph*{Register valuations and updates.}   Let $\ranked{\Gamma, R}$ be finite ranked sets, which are called the \emph{output alphabet} and \emph{register names} respectively.  
A \emph{register valuation} (over $\rGamma$ and $\ranked R$) is defined to be any arity-preserving function from the register names $\regnames$ to terms $\tmonad \rGamma$. We write $\regvals \rGamma \regnames$ for the set of register valuations. For  $n \in \set{0,1,\ldots}$, an \emph{$n$-ary register update} (over $\Gamma$ and $R$) is defined to be any arity-preserving function
\begin{align*}
    \ranked {u : \regnames \rto \tmonad ( \rGamma + \underbrace{{\regnames + \cdots + \regnames}}_{\text{$n$ times}})}
\end{align*}
A register valuation can be seen as the special case of an $n$-ary register update when $n=0$. 
A $n$-ary register update can be seen as an $n$-ary operation on  register valuations,
\begin{align*}
    [\ranked u] : (\regvals \rGamma \regnames \times \cdots \times \regvals \rGamma \regnames) \to \regvals \rGamma \regnames
\end{align*}
as illustrated in the following picture:
\begin{center}
    picture here
\end{center}
Note that although $\ranked u$ is an arity-preserving function between ranked sets, this is no longer true for $[\ranked u]$, which is simply a function on (non-ranked) sets. On the other hand, $[\ranked u]$ has an arity, and therefore we can view the set of register updates as a ranked set which acts on register updates. 


\begin{definition}[Abstract Streaming Tree Transducer]\label{def:stt}
\ 
    \begin{itemize}
        \item An  \emph{abstract streaming tree transducer} consists of finite ranked sets
        \begin{align*}
           \underbrace{\rSigma}_{\text{input alphabet}} \quad 
           \underbrace{\rGamma}_{\text{output alphabet}} \quad 
           \underbrace{\ranked R}_{\text{registers}} \quad 
           \underbrace{\rDelta \subseteq \text{register updates over $\rGamma$ and $\ranked R$},}_{\text{register updates}}
        \end{align*}
           together with an \emph{update function} $\delta : \trees \rSigma \to \trees \rDelta$ and an \emph{output tree} $\outtree \in \trees \ranked{(\Gamma + R)}$. 
           The semantics of the transducer is the composition of the functions
    \begin{align*}
        \xymatrix{
            \trees \rSigma \ar[r]^{\delta} & \trees \rDelta \ar[r]^{t \mapsto [t]} & (\tmonad \rGamma)^\regnames \ar[r]^{[\outtree]} & \trees \rGamma
        }
    \end{align*}
    where the middle function is defined by 
    \begin{align*}
        [\ranked u \tensorpair{t_1,\ldots,t_n}] = [\ranked u]([t_1],\ldots,[t_n])
    \end{align*}
    and the out function applies a register valuation to the output tree. 
    \item A \emph{first-order streaming tree transducer} is the special case of the above when the following conditions are satisfied:
    \begin{enumerate}
        \item \emph{First-order rational updates.} The function $\delta$ is a first-order rational tree function.
        \item \emph{Copyless.} Every register update $\ranked u \in \rDelta$ is \emph{copyless}\footnote{The copyless restriction does not apply to the output tree, but imposing it also on the output tree would give a model with the same expressive power.}, which means that for every
        \begin{align*}
            r \in \ranked{\underbrace{\regnames + \cdots + \regnames}_{\text{arity of $u$ times}}}
        \end{align*}
        there is at most one $s \in \regnames$ such that $r$ appears in the term  $\ranked u(s)$, and furthermore $r$ appears at most once in that term. 
        \item \emph{Montone.} One can equip the registers $\regnames$ with a total order so that for every update $\ranked u \in \rDelta$ and  every $i \in \set{1,\ldots,\text{arity of $\ranked u$}}$,
        \begin{align*} 
            r \in \regnames \qquad \mapsto \quad \text{the unique $s \in \regnames$ such that the $i$-th copy of $r$ appears in $\ranked u(s)$},
        \end{align*}
        which is a well-defined partial function thanks to the copyless assumption, is monotone in the following sense:
        \begin{align*}
            r \leq s \qquad \text{implies} \qquad  \ranked u_i(r) \le  \ranked u_i(s) \text{ or one of the values is undefined.}
        \end{align*}
    \end{enumerate}
    \end{itemize}

    
\end{definition}


\begin{proposition}\label{prop:stt}
    Every first-order tree transduction is recognised by a first-order streaming tree transducer. 
\end{proposition}

The result for \mso, adjusting for a different syntax,  was proved in~\cite[Theorem 4.6]{alur2017streaming}. The result for fo uses the same ideas. A proof is in the appendix.
\begin{center}
    do this appendix 
\end{center}



% Thanks to the above lemma, to prove Proposition~\ref{prop:forat} it is enough to show that the atomic functions and combinators can derive the (characteristic functions of) the child, until and since queries mentioned in the lemma. This is proved in the appendix. 

% \begin{lemma}\label{lem:decomposition-of-fo-transductions} Every first-order tree function $f$  can be decomposed as
%     \begin{align*}
%         \xymatrix@C=2cm{\trees \Sigma \ar[d]_f \ar[r]^g& \trees \overbrace{(\Delta \otimes \cdots \otimes \Delta)}^{\text{$k$ times}} \ar[d]^{\mathsf{unfold}} \\   \trees \Gamma  & \trees \Delta \ar[l]^h}
%     \end{align*}
%     where 
%     \begin{itemize}
%         \item $\Delta$ is a finite ranked alphabet and $k \in \set{1,2,\ldots}$;
%         \item $g$ is an fo-translation;
%         \item $h$ is recognised by a first-order streaming transducer which has one register, and that register has arity one.
%     \end{itemize}
% \end{lemma}

% By the above lemma, it remains to deal with first-order translations and streaming tree transducers with one unary register. We do this in Sections~\ref{sec:fo-translation} and~\ref{sec:one-register}, respectively.
