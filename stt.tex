


\section{Register tree transducers}
\label{sec:stt}
In this section, we begin the proof of the harder implication in Theorem~\ref{thm:main}, which says that every first-order tree-to-tree transduction is derivable. To prove this, we will pass through an automaton model for tree transductions. 
This automaton model is roughly based on existing transducer models for \mso transductions from~\cite{bloem_comparison_2000,alur2017streaming}.
It processes the input tree bottom-up, and uses registers to store parts of the output tree. The semantics of the transducer model involves two phases: (a) mapping the input tree to an expression that uses register updates; (b) evaluating the expression. We will then show that each of the two phases represents a derivable functions.

%Before giving a formal definition, we present an example based on  pre-order traversal from Example~\ref{ex:pre-order}.
%\begin{example}\label{ex:preorder-register} In Example~\ref{ex:pre-order}, we considered a tree-to-tree function which computed pre-order traversal, using the following input and output alphabets:
%    \mypic{21}
%We now show a transducer which recognises the same function, and which uses  a single register.  After reading processing an input tree, the register stores a unary term (not a tree), which represents the pre-order traversal of the  input tree, and which has a single port in the rightmost leaf. The updates of this transducer are illustrated as follows. If the input tree is a single leaf, then the register is set to the following term:
%    \mypic{47}
%    For a tree which is not a single leaf, and its root symbol has $n>0$ children, we first compute the register value  for each of the $n$  child subtrees, resulting in unary terms $r_1,\ldots,r_n$,  and then we combine these terms into a single one, which is illustrated below for the case of $n=2$:
%    \mypic{34}
%    Once the whole input tree has been processed, resulting in a register value $r$ in the root node, the output tree is obtained from this register value by plugging its port with a node, as illustrated in the following picture:
%    \mypic{48}
%\end{example}
%
%

% We use an algebraic syntax for register tree transducers. 
% \emph{Linear polynomials.} Suppose that $\Sigma$ is a finite ranked alphabet.  For a ranked set $X$, define a \emph{polynomial with variables $X$ over $\Sigma$} to be any term in $\tmonad (\Sigma + X)$. Given such a polynomial $p$, and an arity preserving valuation $v : X \to \tmonad \Sigma$, we define $p(v)\in \tmonad \Sigma$ to be the term obtained from $p$ by replacing each variable with its value under $v$. The arity of $p(v)$ is the same as the arity of $p$.  A polynomial is called \emph{linear}, or non-duplicating, if each variable from $X$ is used at most once.

% \begin{definition}
%     For a ranked set $\Sigma$, define $\aalg_\Sigma$ to be the following multisorted algebra. 
%     \begin{itemize}
%         \item The sorts are arities, i.e.~numbers in $\set{0,1,2,\ldots}$, and elements of sort $n$ are $n$-ary terms in $\tmonad  \Sigma$;
%         \item The operations are the polynomial operations. 
%     \end{itemize}
% \end{definition}


%We now proceed with a more formal definition of register tree transducers.

\paragraph*{Register valuations and updates.} We begin by explaining the purpose of the registers.  The registers store terms, which are parts of the output tree. The registers are ranked: registers of arity zero  store trees, registers of arity one store unary terms, etc.  Fix two finite ranked sets: the \emph{register names} $\regnames$ and the \emph{output alphabet} $\rGamma$.
A \emph{register valuation} is defined to be any arity-preserving function from the register names $\regnames$ to terms $\tmonad \rGamma$. Here is an example:
\mypic{31}
The set of register updates is not a ranked set, hence we write it in black.
To transform register valuations, we use \emph{register updates}.  The idea is that an $n$-ary register update is an operation which inputs $n$ register valuations and outputs a single register valuation. For  $n \in \set{0,1,\ldots}$, an \emph{$n$-ary register update}  is defined to be any arity-preserving function
\begin{align*}
    %\label{eq:reg-operation}
    \ranked {u : \regnames \rto \tmonad ( \rGamma + \underbrace{{\regnames + \cdots + \regnames}}_{\text{$n$ times}})}
\end{align*}
In particular, a register update of arity zero is the same as a register valuation.  
Here is a picture of a binary register update:
\mypic{32}
Every $n$-ary register update induces a operation of type 
\begin{align*}
\text{(register valuations)}^n \to \text{register valuations},
\end{align*}
which outputs a register valuation obtained by taking the update, and replacing the $i$-th copy of a register name with the  contents of that register in the $i$-th input register valuation. 

Register updates have arities, and therefore the ranked set of register updates can be used as labels for trees. For such a  tree 
\begin{align*}
    t \in  \trees(\ranked{\text{register updates}}),
\end{align*}
define its \emph{evaluation} to be the register valuation defined by induction in the natural way: the evaluation of a tree is the register valuation obtained by applying the register update in the root to the register updates obtained by evaluating the child subtrees. (For a tree which is just a leaf, the leaf is labelled by a register update of arity zero, which is the same thing as a register valuation). 

% A register update can be applied not only to register valuations, but also to register updates (which generalise register valuations, since register valuations are register updates of arity 0): if $\ranked{u}$ is an $n$-ary register update, and $\ranked{u_1,\ldots,u_n}$ are register updates of arities $m_1,\ldots,m_n$, then the register update
% \begin{align*}
% \ranked{u}(\ranked {u_1},\ldots,\ranked{u_n})  \qquad \text{of arity $m_1+\cdots + m_n$}
% \end{align*}

\paragraph*{First-order tree relabellings.} A peculiarity of the model is that it does not have states. Instead of states, it uses first-order relabelling -- see below for the definition -- tto  directly assign to each node of the input tree a register update that will be applied in that node\footnote{In this sense our model is more similar to the two-phase process used by Bloem and Engelfriet in~\cite[Theorem 17]{bloem_comparison_2000}, and less similar to the state based model of streaming tree transducers of Alur and D'Antoni~\cite{alur2017streaming}. Since we are interested in capturing first-order transformations, we use first-order relabellings instead of \mso relabellings as in~\cite[p.11]{bloem_comparison_2000}.}.



\begin{definition}[First-order tree relabelling] \label{def:forat}  A \emph{first-order tree relabelling} is given by two finite ranked sets $\rSigma$ and $\rGamma$, called the \emph{input and output alphabets}, and a family 
    \begin{align*}
    \set{\varphi_a(x)}_{a \in \rGamma}
    \end{align*}
    of first-order formulas, which have one free variable and use the vocabulary of trees over  $\rSigma$ (we call such formulas first-order  unary tree queries over $\rSigma$). These formulas need to satisfy the following restriction:
    \begin{enumerate}
        \item[(*)] for every tree over the input alphabet and node in that tree, there is a unique output letter $a \in \rGamma$ such that $\varphi_a(x)$ selects the node; furthermore, the arity of $a$ is the same as the arity of (the label of) the node. 
    \end{enumerate}
The semantics of a  first-order tree relabelling is a function 
\begin{align*}
\trees \rSigma \to \trees \rGamma,
\end{align*}
which changes the label of every node in the input tree to the unique letter described in  (*). 
      \end{definition}


A first-order tree relabelling is a very special case of a first-order tree-to-tree transduction, where only the labelling of the input tree is changed, while the universe as well as the child and descendant relations are not affected. 

\paragraph*{Register transducers.} Having defined registers, register updates, and first-order tree relabellings, we are now ready to define our model of register transducers.


\begin{definition}[First-order register transducer]\label{def:stt}
The syntax of a first-order register transducer consists of: 
\begin{itemize}
    \item \emph{Input and output alphabets} $\rSigma$ and $\rGamma$, which are finite ranked sets.
    \item A finite ranked set of \emph{registers} $\regnames$, equipped with a total order.
    \item A designated \emph{output register} $r \in \regnames$, of arity zero.
    \item A \emph{transition function}, which is a  first-order tree relabelling of type
    \begin{align*}
      \trees{\rSigma} \to \trees{\rDelta}
    \end{align*}for some finite set $\rDelta$ of  register updates over $\regnames$ and $\rGamma$, 
    such that all register updates in  $\rDelta$ are single-use and monotone, as defined below:
    \begin{enumerate}
        \item \emph{Single-use\footnote{The  single-use restriction  is a standard feature of transducer models with linear size increase~\cite{bloem_comparison_2000, alurStreamingStringTransducers2011,alur2017streaming}.   It prohibits iterated duplication of registers, which would lead to exponential size outputs.    
        }.}  An $n$-ary register update $\ranked{u}$ is  called  \emph{single-use} if   every
        \begin{align*}
            r \in \ranked{\underbrace{\regnames + \cdots + \regnames}_{\text{$n$ times}}}
        \end{align*}
        appears in at most one of the terms $\set{\ranked u(s)}_{s \in \regnames}$, and it appears at most once in that term. 
        \item \emph{Monotone.} An $n$-ary  register update $\ranked u$ is called monotone (with respect to the total ordering on registers) if for every $i \in \set{1,\ldots,n}$, the binary relation $\to_i$ on register names $r,s \in \regnames$  defined by
        \begin{align*} 
            r \to_i s \quad \text{if} \quad  \text{the $i$-th copy of $r$ appears in $\ranked u(s)$},
        \end{align*}
        which is a partial function from $r$ to $s$ when $\ranked u$ is single-use, is monotone:
        \begin{align*}
            r_1 \leq r_2 \land r_1 \to_i s_1  \land  r_2 \to_i s_2  \quad \Rightarrow \quad  s_1 \leq s_2
        \end{align*}
    \end{enumerate}
    % \item A \emph{final function}
    % \begin{align*}
    %  F : \trees \rSigma \to \trees (\ranked{\regnames + \rGamma}),
    % \end{align*}
    % which has finitely many outputs  and such that for every output $t$, the   inverse image $F^{-1}(t)$ is first-order definable. The final function has no single-use or monotonicity requirements, it is also not necessarily a tree relabelling (in fact, it cannot be a tree relabelling, because it has finitely many outputs).
\end{itemize}
\end{definition}

The semantics of the transducer is  the function from trees over the input alphabet to trees over the output alphabet  that is defined as follows. First, apply the transition function to the input tree, yielding a tree of register updates. Second, evaluate the tree of register updates, yielding a register valuation. Finally, the output tree is the contents of the designated output register.

% the composition the following three operations:
% \begin{align*}
% \xymatrix@C=1.6cm{
%     \trees{\rSigma} {\ar[r]^{\text{transition}}_{\text{function}}} & \trees {\rDelta} \ar[r]^-{
%     \text{evaluate}
%     } & \rDelta {\ar[r]^{\text{content of }}_{\text{output register}}} & \trees \rGamma
% }
% \end{align*}


The main difference of our model with respect to prior work is that we want to capture  tree transformations defined in first-order logic, as opposed to \mso used in~\cite{bloem_comparison_2000,alurStreamingStringTransducers2011,alur2017streaming}. This is the reason for the monotonicity requirement in Definition~\ref{def:stt}. Monotonicity    prohibits swapping registers in cycles, which could be exploited by a transducer to do modulo counting (which can be done in monadic second-order logic, but not in first-order logic). 
% We conjecture that monotonicity -- which is essential to our model -- cannot be achieved without

 
% The following two examples explain the single-use and monotonicity restrictions. 
% \begin{example}\label{ex:single-use}
%     To see the need for the single-use restriction, consider the following abstract register tree transducer, which is not single-use. The input alphabet has two letters of arities zero and one. There is one register $r$ of arity zero, and the update function is the following tree homomorphism \mypic{33}
% The output tree has one node labelled by  $r$. This function recognised by this transducer maps an input tree (which is a sequence of unary nodes followed by a leaf)  to a complete binary tree of same depth. In particular this, function has exponential size increase, and therefore it cannot be a first-order tree-to-tree transduction, since the latter have linear size increase\footnote{single-use updates imply linear size outputs, but the converse implication is also true: a corollary of~\cite[Theorem 7.1]{engelfriet_macro_2003} is that  if a  register tree transducer has linear size increase but not necessarily single-use updates, then it is equivalent to a register tree transducer   which has single-use updates.}.
% \end{example}

% \begin{example}\label{ex:monotone}
%     To see the need for the monotonicity restriction, consider the following abstract register tree transducer, which violates monotonicity. The input alphabet is the same as in Example~\ref{ex:single-use}, i.e.~there are two letters of arities zero and one. There are two registers $r,s$ of arity zero, and the update function is the following tree homomorphism \mypic{35}
%     The output tree has one node labelled by  $r$. 
% Because the two registers get swapped in every step (which is a violation of monotonicity), the output  tree will have a unary (blue)  node if and only if the input tree has an even number of nodes. It follows that the recognised function is not a first-order tree-to-tree transducer, because first-order logic cannot compute parity. 
% \end{example}

The main result of this section is Theorem~\ref{thm:stt} below, which says that register transducers are expressively complete for first-order tree-to-tree transductions. The proof uses the composition method for logic,  following the same lines as  similar results for monadic second-order logic which can be found in~\cite[Theorem 4.6]{alur2017streaming} and~\cite[Theorem 14]{bloem_comparison_2000}. 

\begin{theorem}\label{thm:stt}
    Every first-order tree-to-tree transduction is recognised by a  register transducer. 
\end{theorem}

The converse  inclusion in the above theorem is also true. This is can be shown directly without much difficulty, following the same lines as in~\cite[Section 5]{bloem_comparison_2000}.  The converse inclusion also follows indirectly  from the other results in this paper: (a) we will show in the following sections that every function computed by the transducer is derivable; and (b)  derivable functions are first-order tree-to-tree transductions by the easy implication in Theorem~\ref{thm:main}.

\paragraph*{Proof strategy for Sections~\ref{sec:fo-translation}--\ref{sec:one-register}.} Thanks to Theorem~\ref{thm:stt}, to prove that every first-order tree-to-tree transduction is derivable, it suffices to prove derivability for first-order register transducers. The computation in the transducer has two main steps: a first-order relabelling, followed by evaluation of the register updates. The first step will be handled in Section~\ref{sec:fo-translation}, and the second step will be handled in Sections~\ref{sec:stt-derivable} and~\ref{sec:one-register}.




% Thanks to the above lemma, to prove Proposition~\ref{prop:forat} it is enough to show that the prime functions and combinators can derive the (characteristic functions of) the child, until and since queries mentioned in the lemma. This is proved in the appendix. 

% \begin{lemma}\label{lem:decomposition-of-fo-transductions} Every first-order tree function $f$  can be decomposed as
%     \begin{align*}
%         \xymatrix@C=2cm{\trees \Sigma \ar[d]_f \ar[r]^g& \trees \overbrace{(\Delta \otimes \cdots \otimes \Delta)}^{\text{$k$ times}} \ar[d]^{\mathsf{unfold}} \\   \trees \Gamma  & \trees \Delta \ar[l]^h}
%     \end{align*}
%     where 
%     \begin{itemize}
%         \item $\Delta$ is a finite ranked alphabet and $k \in \set{1,2,\ldots}$;
%         \item $g$ is an fo-translation;
%         \item $h$ is recognised by a first-order register transducer which has one register, and that register has arity one.
%     \end{itemize}
% \end{lemma}

% By the above lemma, it remains to deal with first-order translations and register tree transducers with one unary register. We do this in Sections~\ref{sec:fo-translation} and~\ref{sec:one-register}, respectively.
