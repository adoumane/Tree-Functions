


\section{Register tree transducers}
\label{sec:stt}
In this section, we introduce an automaton model for tree-to-tree functions, and prove that it defines the same functions as first-order tree-to-tree transductions. 
The automaton model is roughly based on streaming tree transducers~\cite{alur2017streaming}.
It processes the input tree bottom-up, and uses registers to store parts of the output tree.

%Before giving a formal definition, we present an example based on  pre-order traversal from Example~\ref{ex:pre-order}.
%\begin{example}\label{ex:preorder-register} In Example~\ref{ex:pre-order}, we considered a tree-to-tree function which computed pre-order traversal, using the following input and output alphabets:
%    \mypic{21}
%We now show a transducer which recognises the same function, and which uses  a single register.  After reading processing an input tree, the register stores a unary term (not a tree), which represents the pre-order traversal of the  input tree, and which has a single port in the rightmost leaf. The updates of this transducer are illustrated as follows. If the input tree is a single leaf, then the register is set to the following term:
%    \mypic{47}
%    For a tree which is not a single leaf, and its root symbol has $n>0$ children, we first compute the register value  for each of the $n$  child subtrees, resulting in unary terms $r_1,\ldots,r_n$,  and then we combine these terms into a single one, which is illustrated below for the case of $n=2$:
%    \mypic{34}
%    Once the whole input tree has been processed, resulting in a register value $r$ in the root node, the output tree is obtained from this register value by plugging its port with a node, as illustrated in the following picture:
%    \mypic{48}
%\end{example}
%
%

% We use an algebraic syntax for register tree transducers. 
% \emph{Linear polynomials.} Suppose that $\Sigma$ is a finite ranked alphabet.  For a ranked set $X$, define a \emph{polynomial with variables $X$ over $\Sigma$} to be any term in $\tmonad (\Sigma + X)$. Given such a polynomial $p$, and an arity preserving valuation $v : X \to \tmonad \Sigma$, we define $p(v)\in \tmonad \Sigma$ to be the term obtained from $p$ by replacing each variable with its value under $v$. The arity of $p(v)$ is the same as the arity of $p$.  A polynomial is called \emph{linear}, or non-duplicating, if each variable from $X$ is used at most once.

% \begin{definition}
%     For a ranked set $\Sigma$, define $\aalg_\Sigma$ to be the following multisorted algebra. 
%     \begin{itemize}
%         \item The sorts are arities, i.e.~numbers in $\set{0,1,2,\ldots}$, and elements of sort $n$ are $n$-ary terms in $\tmonad  \Sigma$;
%         \item The operations are the polynomial operations. 
%     \end{itemize}
% \end{definition}


%We now proceed with a more formal definition of register tree transducers.

\paragraph*{Register valuations and updates.}   Let $\ranked{\Gamma, R}$ be finite ranked sets.
A \emph{register valuation} over output alphabet $\rGamma$ and register names $\ranked R$ is defined to be any arity-preserving function from the register names $\regnames$ to terms $\tmonad \rGamma$. Here is an example, which uses registers $r,s$ of arities two and zero:
\mypic{31}
To transform register valuations, we use \emph{register updates}.  For  $n \in \set{0,1,\ldots}$, an \emph{$n$-ary register update} (over $\rGamma$ and $\ranked R$) is defined to be any arity-preserving function
\begin{align}\label{eq:reg-operation}
    \ranked {u : \regnames \rto \tmonad ( \rGamma + \underbrace{{\regnames + \cdots + \regnames}}_{\text{$n$ times}})}
\end{align}
In particular, a register update of arity zero is the same as a register valuation.
Here is a picture of a binary register update:
\mypic{32}
Every $n$-ary register update $\ranked u$ induces a operation of type 
\begin{align*}
\text{(register valuations)}^n \to \text{register valuations},
\end{align*}
which outputs the register valuation obtained from $\ranked u$ by replacing  the $i$-th copy of a register name with the  contents of that register in the $i$-th input register valuation. 

Since register updates have arities, the register updates are a ranked set, and therefore  we can build trees  with nodes labelled by register updates. For such a  tree 
\begin{align*}
    t \in  \trees(\ranked{\text{register updates}}),
\end{align*}
define its \emph{evaluation} to be the register valuation defined by induction in the natural way: the evaluation of a tree with root label $\ranked u$ and child subtrees $t_1,\ldots,t_n$ is obtained  by applying the register update $\ranked u$ to the evaluations of the $t_1,\ldots, t_n$. In the special case of $n=0$, the tree $t$ consists of a register update of arity zero, which is the same thing as a register valuation. 

% A register update can be applied not only to register valuations, but also to register updates (which generalise register valuations, since register valuations are register updates of arity 0): if $\ranked{u}$ is an $n$-ary register update, and $\ranked{u_1,\ldots,u_n}$ are register updates of arities $m_1,\ldots,m_n$, then the register update
% \begin{align*}
% \ranked{u}(\ranked {u_1},\ldots,\ranked{u_n})  \qquad \text{of arity $m_1+\cdots + m_n$}
% \end{align*}

\paragraph*{Register transducers.} Having defined registers and their updates, we proceed to define register transducers. The general idea is that the transducer assigns to each node of the input tree a register update using a first-order tree relabeling, these register updates are then evaluated, and the output tree is found in a designated output register. 



\begin{definition}[Register  Transducer]\label{def:stt}
The syntax of a register transducer consists of: 
\begin{itemize}
    \item Input and output alphabets $\rSigma$ and $\rGamma$, which are finite ranked sets.
    \item A finite ranked set of \emph{registers} $\regnames$, equipped with a total order.
    \item A distinguished \emph{output register} in $\regnames$ of arity zero.
    \item A \emph{transition function}, which is a  first-order tree relabelling of type
    \begin{align*}
      \trees{\rSigma} \to \trees{\rDelta}
    \end{align*}for some finite set $\rDelta$ of  register updates over $\regnames$ and $\rGamma$, 
    such that all register updates in  $\rDelta$ are single-use and monotone, as defined below:
    \begin{enumerate}
        \item \emph{Single-use.}  An $n$-ary register update $\ranked{u}$ is  called  \emph{single-use} if   every
        \begin{align*}
            r \in \ranked{\underbrace{\regnames + \cdots + \regnames}_{\text{$n$ times}}}
        \end{align*}
        appears in at most one of the terms $\set{\ranked u(s)}_{s \in \regnames}$, and it appears at most once in that term. 
        \item \emph{Monotone.} An $n$-ary  register update $\ranked u$ is called monotone (with respect to the fixed total ordering on registers) if for every $i \in \set{1,\ldots,n}$, the relation defined by
        \begin{align*} 
            r \to_i s \quad \text{if} \quad  \text{the $i$-th copy of $r$ appears in $\ranked u(s)$},
        \end{align*}
        which is a partial function from $r$ to $s$ when $\ranked u$ is single-use, satisfies:
        \begin{align*}
            r_1 \leq r_2 \text{ and } r_1 \to_i s_1 \text{ and } r_2 \to_i s_2  \qquad \text{implies} \qquad  s_1 \leq s_2
        \end{align*}
    \end{enumerate}
\end{itemize}
\end{definition}

The function computed by a register transducer is the composition the following three operations:
\begin{align*}
\xymatrix@C=1.6cm{
    \trees{\rSigma} {\ar[r]^{\text{transition}}_{\text{function}}} & \trees {\rDelta} \ar[r]^-{
    \text{evaluate}
    } & \rDelta {\ar[r]^{\text{content of }}_{\text{output register}}} & \trees \rGamma
}
\end{align*}

The  single-use restriction in the above definition is a standard feature of transducer models aimed at capturing transformations of linear size increase~\cite{alurStreamingStringTransducers2011,alur2017streaming}. It prohibits iterated duplication of registers, which would lead to exponential size outputs. The more unusual aspects of our model are the monotonicity requirement and the use of first-order tree relabellings. In fact, our model can be seen as a variant of  single-use streaming tree transducers from~\cite{alur2017streaming} with the following two differences (apart from less important differences in the employed syntax):
\begin{enumerate}
    \item  In~\cite{alur2017streaming}, there is no order on the registers and the monotonicity requirement is lifted. The monotonicity requirement in Definition~\ref{def:stt}  is related to our use of first-order logic, and not monadic second-order logic as in~\cite{alur2017streaming}. Monotonicity    prohibits swapping registers in cycles, which could be exploited by a transducer to do modulo counting (which can be done in monadic second-order logic, but not in first-order logic).
    \item In~\cite{alur2017streaming}, the transition function can use monadic second-order logic (as opposed to first-order logic as used in our model), but it does not have lookahead (as opposed to our model, where the update associated to a node  of the input tree can depend on the all other nodes in the input tree, and not just those that are earlier in pre-order traversal).  We conjecture that monotonicity -- which is essential to our model -- cannot be achieved without   lookahead.
\end{enumerate}

 
% The following two examples explain the single-use and monotonicity restrictions. 
% \begin{example}\label{ex:single-use}
%     To see the need for the single-use restriction, consider the following abstract register tree transducer, which is not single-use. The input alphabet has two letters of arities zero and one. There is one register $r$ of arity zero, and the update function is the following tree homomorphism \mypic{33}
% The output tree has one node labelled by  $r$. This function recognised by this transducer maps an input tree (which is a sequence of unary nodes followed by a leaf)  to a complete binary tree of same depth. In particular this, function has exponential size increase, and therefore it cannot be a first-order tree-to-tree transduction, since the latter have linear size increase\footnote{single-use updates imply linear size outputs, but the converse implication is also true: a corollary of~\cite[Theorem 7.1]{engelfriet_macro_2003} is that  if a  register tree transducer has linear size increase but not necessarily single-use updates, then it is equivalent to a register tree transducer   which has single-use updates.}.
% \end{example}

% \begin{example}\label{ex:monotone}
%     To see the need for the monotonicity restriction, consider the following abstract register tree transducer, which violates monotonicity. The input alphabet is the same as in Example~\ref{ex:single-use}, i.e.~there are two letters of arities zero and one. There are two registers $r,s$ of arity zero, and the update function is the following tree homomorphism \mypic{35}
%     The output tree has one node labelled by  $r$. 
% Because the two registers get swapped in every step (which is a violation of monotonicity), the output  tree will have a unary (blue)  node if and only if the input tree has an even number of nodes. It follows that the recognised function is not a first-order tree-to-tree transducer, because first-order logic cannot compute parity. 
% \end{example}

The main result of this section is Theorem~\ref{thm:stt} below, which says that register transducers are expressively complete for first-order tree-to-tree transductions. The proof uses the composition method for logic,  following the same lines as  similar results for monadic second-order logic which can be found in~\cite[Theorem 4.6]{alur2017streaming} and~\cite[Theorem 14]{bloem_comparison_2000}. 

\begin{theorem}\label{thm:stt}
    Every first-order tree-to-tree transduction is recognised by a  register transducer. 
\end{theorem}
The converse inclusion in the above theorem is also true, i.e.~every register transducer recognises a first-order tree-to-tree transduction; this will follow from Propositions~\ref{prop:forat} and~\ref{prop:many-register}. 



% Thanks to the above lemma, to prove Proposition~\ref{prop:forat} it is enough to show that the atomic functions and combinators can derive the (characteristic functions of) the child, until and since queries mentioned in the lemma. This is proved in the appendix. 

% \begin{lemma}\label{lem:decomposition-of-fo-transductions} Every first-order tree function $f$  can be decomposed as
%     \begin{align*}
%         \xymatrix@C=2cm{\trees \Sigma \ar[d]_f \ar[r]^g& \trees \overbrace{(\Delta \otimes \cdots \otimes \Delta)}^{\text{$k$ times}} \ar[d]^{\mathsf{unfold}} \\   \trees \Gamma  & \trees \Delta \ar[l]^h}
%     \end{align*}
%     where 
%     \begin{itemize}
%         \item $\Delta$ is a finite ranked alphabet and $k \in \set{1,2,\ldots}$;
%         \item $g$ is an fo-translation;
%         \item $h$ is recognised by a first-order register transducer which has one register, and that register has arity one.
%     \end{itemize}
% \end{lemma}

% By the above lemma, it remains to deal with first-order translations and register tree transducers with one unary register. We do this in Sections~\ref{sec:fo-translation} and~\ref{sec:one-register}, respectively.
